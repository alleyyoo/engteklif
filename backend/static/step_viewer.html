<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>EngTeklif 3D STEP Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: "Inter", "Segoe UI", Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #2c3e50;
        overflow: hidden;
        height: 100vh;
        touch-action: manipulation;
      }

      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid rgba(52, 152, 219, 0.2);
        display: flex;
        align-items: center;
        padding: 0 20px;
        z-index: 1000;
        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
      }

      .logo {
        font-weight: 800;
        font-size: 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .header-controls {
        margin-left: auto;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 12px;
        padding: 10px 16px;
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
      }

      .btn.secondary {
        background: rgba(255, 255, 255, 0.9);
        color: #667eea;
        border: 2px solid #667eea;
      }

      #viewer-container {
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 0;
        background: #f8f9fa;
      }

      .control-panel {
        position: fixed;
        top: 80px;
        left: 20px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        min-width: 280px;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        z-index: 100;
        transform: translateX(-320px);
        transition: transform 0.3s ease;
        display: none;
      }

      .control-panel.visible {
        transform: translateX(0);
        display: block;
      }

      .control-section {
        margin-bottom: 20px;
      }

      .section-title {
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 12px;
        font-size: 16px;
        border-bottom: 2px solid #3498db;
        padding-bottom: 6px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .control-row {
        display: flex;
        gap: 8px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      .control-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 8px 14px;
        cursor: pointer;
        font-family: inherit;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.3s ease;
        flex: 1;
        min-width: 80px;
      }

      .control-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
      }

      .control-btn.active {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      }

      .info-panel {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        min-width: 250px;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        z-index: 100;
      }

      .info-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(52, 152, 219, 0.2);
      }

      .info-label {
        font-weight: 500;
        color: #34495e;
        font-size: 14px;
      }

      .info-value {
        color: #2980b9;
        font-weight: 700;
        font-size: 14px;
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        text-align: center;
        z-index: 2000;
        display: none;
      }

      .loading.show {
        display: block;
      }

      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(46, 204, 113, 0.3);
        z-index: 2000;
        transform: translateX(400px);
        transition: transform 0.3s ease;
        font-weight: 600;
      }

      .toast.show {
        transform: translateX(0);
      }

      .toast.error {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        box-shadow: 0 8px 25px rgba(231, 76, 60, 0.3);
      }

      .error-state,
      .main-page {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f8f9fa;
        flex-direction: column;
        gap: 20px;
      }

      .error-icon,
      .welcome-icon {
        font-size: 72px;
        color: #e74c3c;
      }

      .welcome-icon {
        color: #3498db;
      }

      .error-text,
      .welcome-text {
        background: rgba(255, 255, 255, 0.9);
        padding: 20px 30px;
        border-radius: 12px;
        color: #e74c3c;
        font-weight: 600;
        text-align: center;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        max-width: 400px;
      }

      .welcome-text {
        color: #2c3e50;
      }

      .image-render {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f8f9fa;
        flex-direction: column;
        gap: 20px;
      }

      .image-render img {
        max-width: 90%;
        max-height: 80%;
        object-fit: contain;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      }

      .image-info {
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 8px;
        color: #2c3e50;
        font-weight: 600;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      }

      .toggle-switch {
        position: relative;
        width: 50px;
        height: 25px;
        background: #bdc3c7;
        border-radius: 25px;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .toggle-switch.active {
        background: #3498db;
      }

      .toggle-switch::after {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        width: 21px;
        height: 21px;
        background: white;
        border-radius: 50%;
        transition: transform 0.3s ease;
      }

      .toggle-switch.active::after {
        transform: translateX(25px);
      }

      .feature-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }

      /* Measurement popup styles */
      #distance-popup {
        position: absolute;
        top: 520px;
        right: 24px;
        left: auto;
        transform: none;
        background: #f8fafc;
        border-radius: 15px;
        padding: 22px 28px 18px 28px;
        box-shadow: 0 6px 28px rgba(60, 72, 90, 0.11);
        font-family: inherit;
        font-size: 0.97rem;
        color: #205087;
        z-index: 20;
        transition: opacity 0.3s ease;
        min-width: 210px;
        display: none;
      }

      #popup-content {
        position: relative;
        padding-top: 6px;
      }

      #popup-close {
        position: absolute;
        top: -13px;
        right: -13px;
        background: #eaf1fb;
        color: #205087;
        border-radius: 999px;
        padding: 4px 10px 4px 10px;
        cursor: pointer;
        font-weight: 600;
        font-size: 17px;
        line-height: 20px;
        box-shadow: 0 0 6px rgba(60, 72, 90, 0.12);
        border: 1.5px solid #eaf1fb;
        transition: background 0.12s;
      }

      #popup-close:hover {
        background: #dbeafb;
      }

      /* Mobile-only styles - shown only on mobile */
      .mobile-only {
        display: none;
      }

      /* Mobile FAB container - hidden by default */
      .fab-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: none;
        flex-direction: column;
        gap: 10px;
        z-index: 1000;
      }

      .fab {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        transition: all 0.3s ease;
      }

      .fab:hover,
      .fab:active {
        transform: scale(0.9);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
      }

      .fab.secondary {
        background: rgba(255, 255, 255, 0.9);
        color: #667eea;
        border: 2px solid #667eea;
      }

      .fab.active {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      }

      /* Mobile panel handle */
      .panel-handle {
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        width: 40px;
        height: 4px;
        background: #bdc3c7;
        border-radius: 2px;
        cursor: grab;
        display: none;
      }

      /* Swipe indicator */
      .swipe-indicator {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        z-index: 900;
        animation: fadeInOut 3s ease-in-out;
        pointer-events: none;
        display: none;
      }

      @keyframes fadeInOut {
        0%,
        100% {
          opacity: 0;
        }
        50% {
          opacity: 1;
        }
      }

      /* Mobile-specific styles - only apply on small screens */
      @media (max-width: 768px) {
        body {
          height: 100dvh; /* Dynamic viewport height for mobile */
        }

        .header {
          height: 50px;
          padding: 0 15px;
        }

        .logo {
          font-size: 16px;
          flex: 1;
        }

        .header-controls {
          gap: 5px;
        }

        .btn {
          font-size: 12px;
          padding: 8px 12px;
          border-radius: 8px;
          min-height: 36px;
          gap: 4px;
          white-space: nowrap;
        }

        .btn:hover,
        .btn:active {
          transform: scale(0.95);
        }

        .btn-icon-only {
          padding: 8px;
          font-size: 16px;
        }

        .btn-text {
          display: none;
        }

        #viewer-container {
          top: 50px;
        }

        /* Transform desktop panel to mobile bottom panel */
        .control-panel {
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          top: auto;
          background: rgba(255, 255, 255, 0.95);
          backdrop-filter: blur(20px);
          border-radius: 16px 16px 0 0;
          padding: 20px 15px;
          min-width: auto;
          width: 100%;
          max-height: 70vh;
          transform: translateY(100%);
          transition: transform 0.3s ease;
          box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
        }

        .control-panel.visible {
          transform: translateY(0);
        }

        .panel-handle {
          display: block;
        }

        .control-row {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
          gap: 8px;
        }

        .control-btn {
          border-radius: 8px;
          padding: 10px 8px;
          font-size: 11px;
          min-height: 40px;
          min-width: auto;
          display: flex;
          align-items: center;
          justify-content: center;
          text-align: center;
        }

        .control-btn:hover,
        .control-btn:active {
          transform: scale(0.95);
        }

        .section-title {
          font-size: 14px;
        }

        .feature-toggle {
          justify-content: space-between;
          font-size: 13px;
        }

        .toggle-switch {
          width: 40px;
          height: 20px;
          flex-shrink: 0;
        }

        .toggle-switch::after {
          width: 16px;
          height: 16px;
        }

        .toggle-switch.active::after {
          transform: translateX(20px);
        }

        /* Hide desktop info panel on mobile */
        .info-panel {
          display: none;
        }

        /* Show mobile FAB controls */
        .fab-container {
          display: flex;
          bottom: 15px;
          right: 15px;
        }

        .fab {
          width: 48px;
          height: 48px;
          font-size: 20px;
        }

        /* Mobile toast positioning */
        .toast {
          bottom: 20px;
          left: 50%;
          right: auto;
          transform: translateX(-50%) translateY(100px);
          max-width: 90vw;
          text-align: center;
          font-size: 14px;
        }

        .toast.show {
          transform: translateX(-50%) translateY(0);
        }

        /* Mobile loading adjustments */
        .loading {
          max-width: 80vw;
          padding: 25px;
        }

        .spinner {
          width: 30px;
          height: 30px;
          border-width: 3px;
          margin-bottom: 10px;
        }

        /* Mobile popup adjustments */
        #distance-popup {
          position: fixed;
          top: 50%;
          left: 50%;
          right: auto;
          transform: translate(-50%, -50%);
          min-width: 250px;
          max-width: 90vw;
          font-size: 16px;
          padding: 20px;
        }

        #popup-close {
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 16px;
          top: -10px;
          right: -10px;
        }

        /* Mobile error/welcome pages */
        .error-state,
        .main-page {
          padding: 20px;
          text-align: center;
        }

        .error-icon,
        .welcome-icon {
          font-size: 48px;
        }

        .error-text,
        .welcome-text {
          max-width: 90vw;
          font-size: 14px;
          padding: 20px;
        }

        .welcome-text div:first-child {
          font-size: 20px !important;
        }

        .welcome-text div:nth-child(2) {
          font-size: 14px !important;
        }

        .welcome-text div:last-child {
          font-size: 12px !important;
        }

        /* Show mobile swipe indicator */
        .swipe-indicator {
          display: block;
        }

        /* Mobile-specific control adjustments */
        .control-row {
          grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
          gap: 6px;
        }

        .control-btn {
          font-size: 10px;
          padding: 8px 4px;
        }
      }

      /* Portrait orientation optimizations */
      @media (max-width: 768px) and (orientation: portrait) and (max-height: 800px) {
        .control-panel {
          max-height: 60vh;
        }
      }

      /* Landscape orientation optimizations */
      @media (max-width: 768px) and (orientation: landscape) and (max-height: 500px) {
        .header {
          height: 40px;
        }

        #viewer-container {
          top: 40px;
        }

        .control-panel {
          max-height: 50vh;
        }

        .fab-container {
          bottom: 10px;
          right: 10px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Header -->
    <div class="header">
      <div class="logo">🔧 EngTeklif 3D Viewer</div>
      <div class="header-controls">
        <!-- Desktop controls - hidden on mobile via CSS -->
        <button id="toggle-controls" class="btn secondary">
          🎮 <span class="btn-text">Kontroller</span>
        </button>
        <button id="measure-btn" class="btn secondary">
          📏 <span class="btn-text">Ölçüm</span>
        </button>
        <button id="toggle-fullscreen" class="btn secondary">
          📺 <span class="btn-text">Tam Ekran</span>
        </button>
      </div>
    </div>

    <!-- Main Viewer Container -->
    <div id="viewer-container"></div>

    <!-- Control Panel (Desktop: side panel, Mobile: bottom panel) -->
    <div id="control-panel" class="control-panel visible">
      <div class="panel-handle"></div>

      <div class="control-section">
        <div class="section-title">🎮 Görünüm Kontrolleri</div>
        <div class="control-row">
          <button id="reset-view" class="control-btn">🔄 Sıfırla</button>
          <button id="fit-view" class="control-btn">📐 Sığdır</button>
        </div>
        <div class="control-row">
          <button id="front-view" class="control-btn">📋 Ön</button>
          <button id="back-view" class="control-btn">🔙 Arka</button>
          <button id="left-view" class="control-btn">⬅️ Sol</button>
          <button id="right-view" class="control-btn">➡️ Sağ</button>
        </div>
        <div class="control-row">
          <button id="top-view" class="control-btn">⬆️ Üst</button>
          <button id="bottom-view" class="control-btn">⬇️ Alt</button>
          <button id="iso-view" class="control-btn">🎯 İzometrik</button>
        </div>
      </div>

      <div class="control-section">
        <div class="section-title">🎨 Görsel Ayarlar</div>
        <div class="feature-toggle">
          <span>Wireframe:</span>
          <div id="wireframe-toggle" class="toggle-switch"></div>
        </div>
        <div class="feature-toggle">
          <span>Gölgeler:</span>
          <div id="shadows-toggle" class="toggle-switch active"></div>
        </div>
        <div class="feature-toggle">
          <span>Grid:</span>
          <div id="grid-toggle" class="toggle-switch"></div>
        </div>
        <div class="feature-toggle">
          <span>Eksenler:</span>
          <div id="axes-toggle" class="toggle-switch active"></div>
        </div>
        <div class="feature-toggle">
          <span>Prizma:</span>
          <div id="bbox-toggle" class="toggle-switch"></div>
        </div>
      </div>

      <div class="control-section">
        <div class="section-title">🎨 Renk Modu</div>
        <div class="control-row">
          <button id="vertex-color-btn" class="control-btn">
            🌈 Vertex Renk
          </button>
          <button id="solid-color-btn" class="control-btn active">
            🎨 Düz Gri
          </button>
        </div>
      </div>

      <div class="control-section">
        <div class="section-title">🎨 Malzeme</div>
        <div class="control-row">
          <button id="material-aluminum" class="control-btn">
            🔗 Alüminyum
          </button>
          <button id="material-steel" class="control-btn">🔩 Çelik</button>
          <button id="material-plastic" class="control-btn">🎨 Plastik</button>
        </div>
      </div>
    </div>

    <!-- Info Panel (Desktop only) -->
    <div id="info-panel" class="info-panel">
      <div class="section-title">📊 Model Bilgileri</div>
      <div id="model-info">
        <div class="info-row">
          <span class="info-label">Durum:</span>
          <span class="info-value" id="status-value">Yükleniyor...</span>
        </div>
      </div>
    </div>

    <!-- Mobile FAB Controls (Mobile only) -->
    <div class="fab-container">
      <button id="mobile-toggle-controls" class="fab secondary">🎮</button>
      <button id="mobile-measure-btn" class="fab secondary">📏</button>
    </div>

    <!-- Loading Indicator -->
    <div id="loading" class="loading">
      <div class="spinner"></div>
      <div id="loading-text">Model yükleniyor...</div>
    </div>

    <!-- Toast Notifications -->
    <div id="toast" class="toast"></div>

    <!-- Distance Measurement Popup -->
    <div id="distance-popup">
      <div id="popup-content">
        <span id="popup-close">&times;</span>
        <p id="popup-text"></p>
      </div>
    </div>

    <!-- Mobile Swipe Indicator -->
    <div id="swipe-indicator" class="swipe-indicator">
      Yukarı kaydırarak kontrolleri açın
    </div>

    <script type="module">
      import * as THREE from "https://esm.sh/three@0.176.0";
      import { OrbitControls } from "https://esm.sh/three@0.176.0/examples/jsm/controls/OrbitControls.js";
      import { STLLoader } from "https://esm.sh/three@0.176.0/examples/jsm/loaders/STLLoader.js";

      class ResponsiveEngTeklifSTEPViewer {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.model = null;
          this.lights = [];
          this.isLoading = false;
          this.currentAnalysisId = null;
          this.accessToken = null;
          this.currentColorMode = "solid";
          this.measurementMode = false;
          this.selectedPoints = [];
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.mouse3D = new THREE.Vector3();
          this.isMobile = window.innerWidth <= 768;
          this.touchStartY = 0;

          this.init();
          this.setupEventListeners();

          if (this.isMobile) {
            this.setupMobileGestures();
            this.showSwipeIndicator();
          }

          this.checkForAnalysisId();
        }

        init() {
          // Scene setup
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0xf4f4f4);

          // Camera setup
          this.camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth /
              (window.innerHeight - (this.isMobile ? 50 : 60)),
            1,
            1000
          );
          this.camera.position.set(50, 50, 50);

          // Renderer setup with mobile optimizations
          this.renderer = new THREE.WebGLRenderer({
            antialias: !this.isMobile,
            alpha: true,
            powerPreference: this.isMobile ? "low-power" : "high-performance",
          });

          const headerHeight = this.isMobile ? 50 : 60;
          this.renderer.setSize(
            window.innerWidth,
            window.innerHeight - headerHeight
          );
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.2;

          // Controls setup
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enableDamping = true;
          this.controls.dampingFactor = this.isMobile ? 0.1 : 0.05;
          this.controls.screenSpacePanning = false;
          this.controls.minDistance = 10;
          this.controls.maxDistance = 1000;

          if (this.isMobile) {
            this.controls.rotateSpeed = 0.5;
            this.controls.zoomSpeed = 0.8;
            this.controls.panSpeed = 0.8;
            this.controls.enableKeys = false;
          }

          // Lighting setup
          this.setupLighting();

          // Grid and axes
          this.setupGridAndAxes();

          // Start render loop
          this.animate();
        }

        setupLighting() {
          // Enhanced lighting similar to original
          const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
          light1.position.set(1, 1, 1);
          this.scene.add(light1);

          const light2 = new THREE.AmbientLight(0xffffff, 0.2);
          this.scene.add(light2);

          const light3 = new THREE.DirectionalLight(0xffffff, 0.5);
          light3.position.set(0, -1, 0);
          this.scene.add(light3);

          const lightZ1 = new THREE.DirectionalLight(0xffffff, 0.4);
          lightZ1.position.set(0, 0, 1);
          this.scene.add(lightZ1);

          const lightZ2 = new THREE.DirectionalLight(0xffffff, 0.4);
          lightZ2.position.set(0, 0, -1);
          this.scene.add(lightZ2);

          const lightX1 = new THREE.DirectionalLight(0xffffff, 0.25);
          lightX1.position.set(1, 0, 0);
          this.scene.add(lightX1);

          const lightX2 = new THREE.DirectionalLight(0xffffff, 0.25);
          lightX2.position.set(-1, 0, 0);
          this.scene.add(lightX2);

          const topLight = new THREE.DirectionalLight(0xffffff, 0.9);
          topLight.position.set(0, 1, 0);
          this.scene.add(topLight);

          const sideLight1 = new THREE.DirectionalLight(0xffffff, 0.4);
          sideLight1.position.set(1, 0.5, 0.5);
          this.scene.add(sideLight1);

          const sideLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
          sideLight2.position.set(-1, 0.5, -0.5);
          this.scene.add(sideLight2);
        }

        setupGridAndAxes() {
          // Grid
          const gridHelper = new THREE.GridHelper(200, 50);
          gridHelper.name = "grid";
          gridHelper.visible = false;
          this.scene.add(gridHelper);

          // Axes
          const axesHelper = new THREE.AxesHelper(50);
          axesHelper.name = "axes";
          this.scene.add(axesHelper);
        }

        setupMobileGestures() {
          const controlPanel = document.getElementById("control-panel");
          const panelHandle = document.querySelector(".panel-handle");

          let startY = 0;
          let currentY = 0;
          let isDragging = false;
          let initialTransform = 0;

          const handleTouchStart = (e) => {
            startY = e.touches[0].clientY;
            currentY = startY;
            isDragging = true;

            const transform = controlPanel.style.transform;
            if (transform.includes("translateY")) {
              const match = transform.match(/translateY\(([^)]+)\)/);
              if (match) {
                initialTransform = parseInt(match[1]) || 0;
              }
            } else {
              initialTransform = controlPanel.classList.contains("visible")
                ? 0
                : 100;
            }

            controlPanel.style.transition = "none";
          };

          const handleTouchMove = (e) => {
            if (!isDragging) return;

            e.preventDefault();
            currentY = e.touches[0].clientY;
            const deltaY = currentY - startY;
            const percent = Math.max(
              0,
              Math.min(
                100,
                initialTransform + (deltaY / window.innerHeight) * 100
              )
            );

            controlPanel.style.transform = `translateY(${percent}%)`;
          };

          const handleTouchEnd = (e) => {
            if (!isDragging) return;

            isDragging = false;
            controlPanel.style.transition = "transform 0.3s ease";

            const deltaY = currentY - startY;
            const threshold = window.innerHeight * 0.1;

            if (Math.abs(deltaY) > threshold) {
              if (deltaY > 0) {
                this.hideMobilePanel();
              } else {
                this.showMobilePanel();
              }
            } else {
              if (controlPanel.classList.contains("visible")) {
                controlPanel.style.transform = "translateY(0)";
              } else {
                controlPanel.style.transform = "translateY(100%)";
              }
            }
          };

          panelHandle.addEventListener("touchstart", handleTouchStart, {
            passive: false,
          });
          controlPanel.addEventListener("touchstart", handleTouchStart, {
            passive: false,
          });
          document.addEventListener("touchmove", handleTouchMove, {
            passive: false,
          });
          document.addEventListener("touchend", handleTouchEnd, {
            passive: false,
          });
        }

        showMobilePanel() {
          const controlPanel = document.getElementById("control-panel");
          controlPanel.classList.add("visible");
          controlPanel.style.transform = "translateY(0)";
        }

        hideMobilePanel() {
          const controlPanel = document.getElementById("control-panel");
          controlPanel.classList.remove("visible");
          controlPanel.style.transform = "translateY(100%)";
        }

        showSwipeIndicator() {
          const indicator = document.getElementById("swipe-indicator");
          if (indicator) {
            indicator.style.display = "block";
            setTimeout(() => {
              indicator.style.display = "none";
            }, 3000);
          }
        }

        setupEventListeners() {
          this.setupControlButtons();
          this.setupMeasurement();

          // Window resize
          window.addEventListener("resize", () => {
            const wasMobile = this.isMobile;
            this.isMobile = window.innerWidth <= 768;

            this.camera.aspect =
              window.innerWidth /
              (window.innerHeight - (this.isMobile ? 50 : 60));
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(
              window.innerWidth,
              window.innerHeight - (this.isMobile ? 50 : 60)
            );

            // If switching between mobile/desktop, setup appropriate gestures
            if (wasMobile !== this.isMobile) {
              if (this.isMobile) {
                this.setupMobileGestures();
              }
            }
          });

          // Desktop toggle controls
          document
            .getElementById("toggle-controls")
            .addEventListener("click", () => {
              if (this.isMobile) {
                const panel = document.getElementById("control-panel");
                if (panel.classList.contains("visible")) {
                  this.hideMobilePanel();
                } else {
                  this.showMobilePanel();
                }
              } else {
                document
                  .getElementById("control-panel")
                  .classList.toggle("visible");
              }
            });

          // Mobile FAB controls
          document
            .getElementById("mobile-toggle-controls")
            .addEventListener("click", () => {
              const panel = document.getElementById("control-panel");
              if (panel.classList.contains("visible")) {
                this.hideMobilePanel();
              } else {
                this.showMobilePanel();
              }
            });

          // Fullscreen
          document
            .getElementById("toggle-fullscreen")
            .addEventListener("click", () => {
              if (document.fullscreenElement) {
                document.exitFullscreen();
              } else {
                document.documentElement.requestFullscreen();
              }
            });
        }

        setupMeasurement() {
          // Desktop measurement button
          const measureBtn = document.getElementById("measure-btn");
          measureBtn.addEventListener("click", () => {
            this.toggleMeasurementMode(measureBtn);
          });

          // Mobile measurement FAB
          const mobileMeasureBtn =
            document.getElementById("mobile-measure-btn");
          mobileMeasureBtn.addEventListener("click", () => {
            this.toggleMeasurementMode(mobileMeasureBtn);
          });

          // Close popup handler
          document
            .getElementById("popup-close")
            .addEventListener("click", () => {
              document.getElementById("distance-popup").style.display = "none";
              this.clearMeasurements();
            });
        }

        toggleMeasurementMode(button) {
          this.measurementMode = !this.measurementMode;

          // Update both buttons
          document
            .getElementById("measure-btn")
            .classList.toggle("active", this.measurementMode);
          document
            .getElementById("mobile-measure-btn")
            .classList.toggle("active", this.measurementMode);

          if (this.measurementMode) {
            this.showToast("Ölçüm modu aktif - İki nokta seçin", "info");
          } else {
            this.clearMeasurements();
          }
        }

        setupMeasurementEvents() {
          if (this.measurementEventsSetup) return;

          const handlePointerMove = (event) => {
            if (
              this.measurementMode &&
              this.selectedPoints.length === 1 &&
              this.model
            ) {
              const rect = this.renderer.domElement.getBoundingClientRect();
              let clientX, clientY;

              if (event.touches) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
              } else {
                clientX = event.clientX;
                clientY = event.clientY;
              }

              this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
              this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

              this.raycaster.setFromCamera(this.mouse, this.camera);
              const intersects = this.raycaster.intersectObject(
                this.model,
                true
              );
              if (intersects.length > 0) {
                this.mouse3D.copy(intersects[0].point);
              }
            }
          };

          this.renderer.domElement.addEventListener(
            "mousemove",
            handlePointerMove
          );
          this.renderer.domElement.addEventListener(
            "touchmove",
            handlePointerMove,
            { passive: true }
          );
          this.renderer.domElement.addEventListener("click", (event) =>
            this.onClick(event)
          );
          this.renderer.domElement.addEventListener("touchend", (event) =>
            this.onClick(event)
          );

          this.measurementEventsSetup = true;
        }

        onClick(event) {
          if (
            document.getElementById("distance-popup").style.display === "block"
          )
            return;
          if (!this.model || !this.measurementMode) return;

          if (
            event.target.closest(".control-panel") ||
            event.target.closest(".fab-container")
          ) {
            return;
          }

          const rect = this.renderer.domElement.getBoundingClientRect();
          let clientX, clientY;

          if (event.touches && event.touches[0]) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
          } else if (event.changedTouches && event.changedTouches[0]) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
          } else {
            clientX = event.clientX;
            clientY = event.clientY;
          }

          this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
          this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, this.camera);
          const intersects = this.raycaster.intersectObject(this.model, true);

          if (intersects.length > 0) {
            const point = intersects[0].point.clone();
            this.selectedPoints.push(point);

            const markerSize = this.isMobile ? 0.8 : 0.5;
            const marker = new THREE.Mesh(
              new THREE.SphereGeometry(markerSize),
              new THREE.MeshBasicMaterial({ color: 0xff6666 })
            );
            marker.position.copy(point);
            this.scene.add(marker);
            if (!window._currentMarkers) window._currentMarkers = [];
            window._currentMarkers.push(marker);

            if (this.selectedPoints.length === 1) {
              this.createPreviewLine();
              this.showToast("İkinci noktayı seçin", "info");
            }

            if (this.selectedPoints.length === 2) {
              this.showDistance();
              this.showToast("Mesafe ölçüldü!", "success");
            }
          }
        }

        createPreviewLine() {
          if (window._previewLine) {
            this.scene.remove(window._previewLine);
            window._previewLine = null;
          }

          const dynamicLineGeometry = new THREE.BufferGeometry().setFromPoints([
            this.selectedPoints[0],
            this.selectedPoints[0].clone(),
          ]);

          const dynamicLine = new THREE.Line(
            dynamicLineGeometry,
            new THREE.LineDashedMaterial({
              color: 0xff0000,
              dashSize: 0.2,
              gapSize: 0.1,
            })
          );

          this.scene.add(dynamicLine);
          window._previewLine = dynamicLine;
        }

        showDistance() {
          const geometry = new THREE.BufferGeometry().setFromPoints(
            this.selectedPoints
          );
          const line = new THREE.Line(
            geometry,
            new THREE.LineBasicMaterial({ color: 0x0000ff })
          );
          this.scene.add(line);

          const distance = this.selectedPoints[0].distanceTo(
            this.selectedPoints[1]
          );
          const popup = document.getElementById("distance-popup");
          const popupText = document.getElementById("popup-text");
          popupText.textContent = `Mesafe: ${distance.toFixed(2)} birim`;
          popup.style.display = "block";

          window._currentLine = line;

          if (window._previewLine) {
            this.scene.remove(window._previewLine);
            window._previewLine = null;
          }
        }

        clearMeasurements() {
          if (window._currentMarkers) {
            window._currentMarkers.forEach((m) => this.scene.remove(m));
            window._currentMarkers = [];
          }
          if (window._currentLine) {
            this.scene.remove(window._currentLine);
            window._currentLine = null;
          }
          if (window._previewLine) {
            this.scene.remove(window._previewLine);
            window._previewLine = null;
          }
          this.selectedPoints = [];

          // Update both measure buttons
          document.getElementById("measure-btn").classList.remove("active");
          document
            .getElementById("mobile-measure-btn")
            .classList.remove("active");
        }

        setupControlButtons() {
          // View controls
          document
            .getElementById("reset-view")
            .addEventListener("click", () => {
              this.resetView();
            });

          document.getElementById("fit-view").addEventListener("click", () => {
            this.fitToView();
          });

          // Standard views
          document
            .getElementById("front-view")
            .addEventListener("click", () => {
              this.setStandardView("front");
            });

          document.getElementById("back-view").addEventListener("click", () => {
            this.setStandardView("back");
          });

          document.getElementById("left-view").addEventListener("click", () => {
            this.setStandardView("left");
          });

          document
            .getElementById("right-view")
            .addEventListener("click", () => {
              this.setStandardView("right");
            });

          document.getElementById("top-view").addEventListener("click", () => {
            this.setStandardView("top");
          });

          document
            .getElementById("bottom-view")
            .addEventListener("click", () => {
              this.setStandardView("bottom");
            });

          document.getElementById("iso-view").addEventListener("click", () => {
            this.setStandardView("isometric");
          });

          // Color mode buttons
          document
            .getElementById("vertex-color-btn")
            .addEventListener("click", () => {
              this.setColorMode("vertex");
            });

          document
            .getElementById("solid-color-btn")
            .addEventListener("click", () => {
              this.setColorMode("solid");
            });

          // Visual toggles
          this.setupToggle("wireframe-toggle", (active) => {
            if (this.model) {
              this.model.material.wireframe = active;
            }
          });

          this.setupToggle(
            "shadows-toggle",
            (active) => {
              this.renderer.shadowMap.enabled = active;
            },
            true
          );

          this.setupToggle("grid-toggle", (active) => {
            const grid = this.scene.getObjectByName("grid");
            if (grid) grid.visible = active;
          });

          this.setupToggle(
            "axes-toggle",
            (active) => {
              const axes = this.scene.getObjectByName("axes");
              if (axes) axes.visible = active;
            },
            true
          );

          this.setupToggle("bbox-toggle", (active) => {
            this.toggleBoundingBox(active);
          });

          // Material buttons
          document
            .getElementById("material-aluminum")
            .addEventListener("click", () => {
              this.setMaterial("aluminum");
            });

          document
            .getElementById("material-steel")
            .addEventListener("click", () => {
              this.setMaterial("steel");
            });

          document
            .getElementById("material-plastic")
            .addEventListener("click", () => {
              this.setMaterial("plastic");
            });
        }

        setColorMode(mode) {
          if (mode === this.currentColorMode) return;

          this.currentColorMode = mode;

          document
            .querySelectorAll("#vertex-color-btn, #solid-color-btn")
            .forEach((btn) => {
              btn.classList.remove("active");
            });

          if (mode === "vertex") {
            document.getElementById("vertex-color-btn").classList.add("active");
          } else {
            document.getElementById("solid-color-btn").classList.add("active");
          }

          if (this.model && this.currentAnalysisId) {
            this.reloadModelWithColorMode(mode);
          }
        }

        async reloadModelWithColorMode(mode) {
          try {
            const modelPath = `/static/stepviews/${this.currentAnalysisId}/model_${this.currentAnalysisId}.stl`;

            const loader = new STLLoader();
            loader.load(modelPath, (geometry) => {
              geometry.computeVertexNormals();

              let material;
              if (mode === "vertex") {
                const colors = [];
                const position = geometry.attributes.position;
                for (let i = 0; i < position.count; i++) {
                  const y = position.getY(i);
                  const color = new THREE.Color().setHSL(
                    (y + 50) / 100,
                    1.0,
                    0.5
                  );
                  colors.push(color.r, color.g, color.b);
                }
                geometry.setAttribute(
                  "color",
                  new THREE.Float32BufferAttribute(colors, 3)
                );
                material = new THREE.MeshPhongMaterial({
                  vertexColors: true,
                  side: THREE.DoubleSide,
                  shininess: 100,
                });
              } else {
                material = new THREE.MeshPhongMaterial({
                  color: 0xb0bec5,
                  shininess: 25,
                  specular: 0x222222,
                  flatShading: false,
                  side: THREE.DoubleSide,
                });
              }

              if (this.model) {
                this.scene.remove(this.model);
              }

              this.model = new THREE.Mesh(geometry, material);

              geometry.computeBoundingBox();
              const center = new THREE.Vector3();
              geometry.boundingBox.getCenter(center);
              this.model.position.sub(center);

              this.model.castShadow = true;
              this.model.receiveShadow = true;
              this.scene.add(this.model);
            });
          } catch (error) {
            console.error("Color mode reload error:", error);
          }
        }

        toggleBoundingBox(active) {
          if (!active) {
            const bbox = this.scene.getObjectByName("boundingBox");
            if (bbox) {
              this.scene.remove(bbox);
            }
            return;
          }

          if (this.model) {
            const box = new THREE.Box3().setFromObject(this.model);
            const size = new THREE.Vector3();
            box.getSize(size);
            const center = new THREE.Vector3();
            box.getCenter(center);

            const dims = [size.x, size.y, size.z];
            const minIndex = dims.indexOf(Math.min(...dims));

            if (minIndex === 0) size.x += 0.5;
            else size.x += 1.0;
            if (minIndex === 1) size.y += 0.5;
            else size.y += 1.0;
            if (minIndex === 2) size.z += 0.5;
            else size.z += 1.0;

            const boxGeom = new THREE.BoxGeometry(size.x, size.y, size.z);
            const boxMat = new THREE.MeshBasicMaterial({
              color: 0x999999,
              transparent: true,
              opacity: 0.8,
            });
            const bboxMesh = new THREE.Mesh(boxGeom, boxMat);
            bboxMesh.name = "boundingBox";
            bboxMesh.position.copy(center);
            this.scene.add(bboxMesh);
          }
        }

        setupToggle(id, callback, initialState = false) {
          const toggle = document.getElementById(id);
          let active = initialState;

          if (initialState) {
            toggle.classList.add("active");
          }

          toggle.addEventListener("click", () => {
            active = !active;
            toggle.classList.toggle("active", active);
            callback(active);
          });
        }

        checkForAnalysisId() {
          const path = window.location.pathname;
          const fullMatch = path.match(/\/step-viewer\/([^\/]+)\/([^\/]+)$/);
          const simpleMatch = path.match(/\/step-viewer\/([^\/]+)$/);

          if (fullMatch) {
            this.currentAnalysisId = fullMatch[1];
            this.accessToken = fullMatch[2];
            this.loadAnalysisModel(this.currentAnalysisId);
          } else if (simpleMatch) {
            this.currentAnalysisId = simpleMatch[1];
            this.accessToken = null;
            this.loadAnalysisModel(this.currentAnalysisId);
          } else {
            this.showMainPage();
          }
        }

        async loadAnalysisModel(analysisId) {
          try {
            this.showLoading("3D model yükleniyor...");

            const headers = {
              "Content-Type": "application/json",
            };

            if (this.accessToken) {
              headers["Authorization"] = `Bearer ${this.accessToken}`;
            }

            const modelPath = `/static/stepviews/${analysisId}/model_${analysisId}.stl`;

            try {
              await this.loadSTLFromPath(modelPath);
              await this.loadAnalysisInfo(analysisId);
              this.showToast("3D model başarıyla yüklendi!", "success");
              this.hideLoading();
              return;
            } catch (stlLoadError) {
              console.log("Direct STL load failed, trying API...");
            }

            const modelInfoResponse = await fetch(
              `/api/upload/model-3d/${analysisId}`,
              {
                method: "GET",
                headers: headers,
              }
            );

            if (!modelInfoResponse.ok) {
              throw new Error(
                `Model bilgileri alınamadı (${modelInfoResponse.status})`
              );
            }

            const modelInfo = await modelInfoResponse.json();

            let stlPath = null;

            if (
              modelInfo.success &&
              modelInfo.model_info.models_available.stl?.ready
            ) {
              stlPath = modelInfo.model_info.models_available.stl.path;

              try {
                await this.loadSTLFromPath(stlPath);
                await this.loadAnalysisInfo(analysisId);
                this.showToast("3D model başarıyla yüklendi!", "success");
                this.hideLoading();
                return;
              } catch (stlLoadError) {
                console.error("STL yükleme hatası:", stlLoadError);
              }
            }

            if (!stlPath || !modelInfo.model_info.models_available.stl?.ready) {
              this.showLoading("STL dosyası oluşturuluyor...");

              const analyzeResponse = await fetch(
                `/api/upload/analyze/${analysisId}`,
                {
                  method: "POST",
                  headers: headers,
                }
              );

              if (analyzeResponse.ok) {
                const analyzeResult = await analyzeResponse.json();
              }

              const generateResponse = await fetch(
                `/api/upload/generate-stl/${analysisId}`,
                {
                  method: "POST",
                  headers: headers,
                }
              );

              if (generateResponse.ok) {
                const generateResult = await generateResponse.json();

                if (generateResult.success) {
                  const newStlPath =
                    generateResult.stl_url || generateResult.stl_path;

                  await this.loadSTLFromPath(newStlPath);
                  await this.loadAnalysisInfo(analysisId);

                  this.showToast(
                    "3D model oluşturuldu ve yüklendi!",
                    "success"
                  );
                  this.hideLoading();
                  return;
                } else {
                  throw new Error(
                    generateResult.message || "STL oluşturulamadı"
                  );
                }
              } else {
                throw new Error(
                  `STL oluşturulamadı (${generateResponse.status})`
                );
              }
            }
          } catch (error) {
            console.error("Model yükleme hatası:", error);
            this.showToast(`Model yüklenemedi: ${error.message}`, "error");
            this.showErrorState(error.message);
          } finally {
            this.hideLoading();
          }
        }

        async loadAnalysisInfo(analysisId) {
          try {
            const headers = {
              "Content-Type": "application/json",
            };

            if (this.accessToken) {
              headers["Authorization"] = `Bearer ${this.accessToken}`;
            }

            const configUrl = this.accessToken
              ? `/api/step-viewer/config/${analysisId}/${this.accessToken}`
              : `/api/step-viewer/config/${analysisId}`;

            const configResponse = await fetch(configUrl, {
              method: "GET",
              headers: headers,
            });

            if (configResponse.ok) {
              const configData = await configResponse.json();
              if (configData.success && configData.config) {
                const analysis = {
                  original_filename:
                    configData.config.file_info.original_filename,
                  file_type: configData.config.file_info.file_type,
                  step_analysis: configData.config.step_analysis,
                  enhanced_renders: configData.config.enhanced_renders,
                };

                this.displayAnalysisInfo(analysis);
              }
            }
          } catch (error) {
            console.warn("Analiz bilgileri yüklenemedi:", error);
          }
        }

        async loadSTLFromPath(stlPath) {
          return new Promise((resolve, reject) => {
            if (!stlPath.startsWith("/")) {
              stlPath = "/" + stlPath;
            }

            const loader = new STLLoader();

            loader.load(
              stlPath,
              (geometry) => {
                try {
                  this.processLoadedGeometry(geometry);
                  resolve();
                } catch (error) {
                  reject(error);
                }
              },
              (progress) => {
                if (progress.total > 0) {
                  const percent = Math.round(
                    (progress.loaded / progress.total) * 100
                  );
                  this.showLoading(`STL yükleniyor... ${percent}%`);
                }
              },
              (error) => {
                let errorMessage = "STL dosyası yüklenemedi";
                if (error.message) {
                  errorMessage += `: ${error.message}`;
                } else if (error.type === "load") {
                  errorMessage += " - Dosya bulunamadı veya erişilemiyor";
                }
                reject(new Error(errorMessage));
              }
            );
          });
        }

        processLoadedGeometry(geometry) {
          geometry.computeVertexNormals();
          geometry.computeBoundingBox();

          const center = new THREE.Vector3();
          geometry.boundingBox.getCenter(center);
          geometry.translate(-center.x, -center.y, -center.z);

          let material;
          if (this.currentColorMode === "vertex") {
            const colors = [];
            const position = geometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
              const y = position.getY(i);
              const color = new THREE.Color().setHSL((y + 50) / 100, 1.0, 0.5);
              colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute(
              "color",
              new THREE.Float32BufferAttribute(colors, 3)
            );
            material = new THREE.MeshPhongMaterial({
              vertexColors: true,
              side: THREE.DoubleSide,
              shininess: 100,
            });
          } else {
            material = new THREE.MeshPhongMaterial({
              color: 0xb0bec5,
              shininess: 25,
              specular: 0x222222,
              flatShading: false,
              side: THREE.DoubleSide,
            });
          }

          if (this.model) {
            this.scene.remove(this.model);
          }

          this.model = new THREE.Mesh(geometry, material);
          this.model.castShadow = true;
          this.model.receiveShadow = true;
          this.scene.add(this.model);

          this.fitToView();

          const container = document.getElementById("viewer-container");
          container.innerHTML = "";
          container.appendChild(this.renderer.domElement);

          this.setupMeasurementEvents();
        }

        displayAnalysisInfo(analysis) {
          const analysisDetails = document.getElementById("model-info");
          const stepAnalysis = analysis.step_analysis || {};

          let detailsHTML = `
            <div class="info-row">
              <span class="info-label">Durum:</span>
              <span class="info-value" style="color: #27ae60;">Yüklendi</span>
            </div>
            <div class="info-row">
              <span class="info-label">Dosya:</span>
              <span class="info-value">${
                analysis.original_filename || "Bilinmeyen"
              }</span>
            </div>
            <div class="info-row">
              <span class="info-label">Tip:</span>
              <span class="info-value">${analysis.file_type || "STL"}</span>
            </div>
          `;

          if (stepAnalysis["X (mm)"]) {
            const volume = stepAnalysis["Prizma Hacmi (mm³)"] || 0;
            const surfaceArea = stepAnalysis["Toplam Yüzey Alanı (mm²)"] || 0;

            detailsHTML += `
              <div class="info-row">
                <span class="info-label">Genişlik:</span>
                <span class="info-value">${stepAnalysis["X (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Yükseklik:</span>
                <span class="info-value">${stepAnalysis["Y (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Derinlik:</span>
                <span class="info-value">${stepAnalysis["Z (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Hacim:</span>
                <span class="info-value">${volume.toLocaleString()} mm³</span>
              </div>
              <div class="info-row">
                <span class="info-label">Yüzey:</span>
                <span class="info-value">${surfaceArea.toLocaleString()} mm²</span>
              </div>
            `;
          }

          analysisDetails.innerHTML = detailsHTML;
        }

        showMainPage() {
          const container = document.getElementById("viewer-container");

          const mainPageContainer = document.createElement("div");
          mainPageContainer.className = "main-page";

          const welcomeIcon = document.createElement("div");
          welcomeIcon.className = "welcome-icon";
          welcomeIcon.textContent = "🎯";

          const welcomeText = document.createElement("div");
          welcomeText.className = "welcome-text";
          welcomeText.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 15px; color: #3498db;">🔧 EngTeklif 3D Viewer</div>
            <div style="font-size: 16px; margin-bottom: 20px;">3D STEP model görüntüleyici</div>
            <div style="font-size: 14px; color: #7f8c8d; line-height: 1.6;">
                Model görüntülemek için doğru URL formatını kullanın:<br><br>
                📋 <strong>/step-viewer/{analysis_id}</strong><br>
                🔐 <strong>/step-viewer/{analysis_id}/{access_token}</strong>
            </div>
          `;

          const uploadButton = document.createElement("button");
          uploadButton.className = "btn";
          uploadButton.innerHTML = "📁 Dosya Yükle";
          uploadButton.onclick = () => {
            window.location.href = "/api/upload/supported-formats";
          };

          mainPageContainer.appendChild(welcomeIcon);
          mainPageContainer.appendChild(welcomeText);
          mainPageContainer.appendChild(uploadButton);
          container.innerHTML = "";
          container.appendChild(mainPageContainer);

          document.getElementById("status-value").textContent = "Hazır";
          document.getElementById("status-value").style.color = "#27ae60";
        }

        showErrorState(message) {
          const container = document.getElementById("viewer-container");

          const errorContainer = document.createElement("div");
          errorContainer.className = "error-state";

          const errorIcon = document.createElement("div");
          errorIcon.className = "error-icon";
          errorIcon.textContent = "⚠️";

          const errorText = document.createElement("div");
          errorText.className = "error-text";
          errorText.innerHTML = `
            <div style="font-size: 18px; margin-bottom: 10px;">Model Yüklenemedi</div>
            <div style="font-size: 14px; color: #7f8c8d;">${message}</div>
          `;

          const backButton = document.createElement("button");
          backButton.className = "btn";
          backButton.textContent = "🏠 Ana Sayfaya Dön";
          backButton.onclick = () => {
            window.location.href = "/step-viewer";
          };

          errorContainer.appendChild(errorIcon);
          errorContainer.appendChild(errorText);
          errorContainer.appendChild(backButton);
          container.innerHTML = "";
          container.appendChild(errorContainer);
        }

        resetView() {
          if (this.model) {
            this.camera.position.set(50, 50, 50);
            this.camera.lookAt(0, 0, 0);
            this.controls.target.set(0, 0, 0);
            this.controls.update();
          }
        }

        fitToView() {
          if (this.model) {
            const box = new THREE.Box3().setFromObject(this.model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = this.camera.fov * (Math.PI / 180);
            const cameraDistance =
              Math.abs(maxDim / (2 * Math.tan(fov / 2))) * 1.5;

            const direction = new THREE.Vector3(1, 1, 1).normalize();
            this.camera.position.copy(direction.multiplyScalar(cameraDistance));
            this.camera.lookAt(center);

            this.controls.target.copy(center);
            this.controls.update();
          }
        }

        setStandardView(viewType) {
          if (!this.model) return;

          const box = new THREE.Box3().setFromObject(this.model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const distance = maxDim * 2;

          const positions = {
            front: [center.x, center.y, center.z + distance],
            back: [center.x, center.y, center.z - distance],
            left: [center.x - distance, center.y, center.z],
            right: [center.x + distance, center.y, center.z],
            top: [center.x, center.y + distance, center.z],
            bottom: [center.x, center.y - distance, center.z],
            isometric: [
              center.x + distance * 0.7,
              center.y + distance * 0.7,
              center.z + distance * 0.7,
            ],
          };

          const position = positions[viewType];
          if (position) {
            this.camera.position.set(...position);
            this.camera.lookAt(center);
            this.controls.target.copy(center);
            this.controls.update();
          }

          // Auto-hide mobile panel after view change
          if (this.isMobile) {
            setTimeout(() => {
              this.hideMobilePanel();
            }, 500);
          }
        }

        setMaterial(materialType) {
          if (!this.model) return;

          const materials = {
            aluminum: { color: 0xc0c0c0, shininess: 100 },
            steel: { color: 0x708090, shininess: 80 },
            plastic: { color: 0x4a90e2, shininess: 30 },
          };

          const materialConfig = materials[materialType];
          if (materialConfig) {
            this.model.material.color.setHex(materialConfig.color);
            this.model.material.shininess = materialConfig.shininess;
          }
        }

        showLoading(message = "Yükleniyor...") {
          const loading = document.getElementById("loading");
          const loadingText = document.getElementById("loading-text");
          loadingText.textContent = message;
          loading.classList.add("show");
          this.isLoading = true;
        }

        hideLoading() {
          document.getElementById("loading").classList.remove("show");
          this.isLoading = false;
        }

        showToast(message, type = "success") {
          const toast = document.getElementById("toast");
          toast.textContent = message;
          toast.className = `toast ${type}`;

          if (type === "info") {
            toast.style.background =
              "linear-gradient(135deg, #3498db 0%, #2980b9 100%)";
            toast.style.boxShadow = "0 8px 25px rgba(52, 152, 219, 0.3)";
          }

          toast.classList.add("show");

          setTimeout(
            () => {
              toast.classList.remove("show");
              if (type === "info") {
                toast.style.background = "";
                toast.style.boxShadow = "";
              }
            },
            this.isMobile ? 2000 : 3000
          );
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          if (this.controls) {
            this.controls.update();
          }

          // Update preview line during measurement
          if (window._previewLine && this.selectedPoints.length === 1) {
            const positions =
              window._previewLine.geometry.attributes.position.array;
            positions[3] = this.mouse3D.x;
            positions[4] = this.mouse3D.y;
            positions[5] = this.mouse3D.z;
            window._previewLine.geometry.attributes.position.needsUpdate = true;
          }

          if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
          }
        }
      }

      // Initialize the viewer
      window.addEventListener("DOMContentLoaded", () => {
        new ResponsiveEngTeklifSTEPViewer();
      });
    </script>
  </body>
</html>
