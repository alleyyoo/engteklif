<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EngTeklif 3D STEP Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", "Segoe UI", Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #2c3e50;
        overflow: hidden;
        height: 100vh;
      }

      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid rgba(52, 152, 219, 0.2);
        display: flex;
        align-items: center;
        padding: 0 20px;
        z-index: 1000;
        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
      }

      .logo {
        font-weight: 800;
        font-size: 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .header-controls {
        margin-left: auto;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 12px;
        padding: 10px 16px;
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
      }

      .btn.secondary {
        background: rgba(255, 255, 255, 0.9);
        color: #667eea;
        border: 2px solid #667eea;
      }

      #viewer-container {
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 0;
        background: #f8f9fa;
      }

      .control-panel {
        position: fixed;
        top: 80px;
        left: 20px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        min-width: 280px;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        z-index: 100;
        transform: translateX(-320px);
        transition: transform 0.3s ease;
      }

      .control-panel.visible {
        transform: translateX(0);
      }

      .control-section {
        margin-bottom: 20px;
      }

      .section-title {
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 12px;
        font-size: 16px;
        border-bottom: 2px solid #3498db;
        padding-bottom: 6px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .control-row {
        display: flex;
        gap: 8px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      .control-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 8px 14px;
        cursor: pointer;
        font-family: inherit;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.3s ease;
        flex: 1;
        min-width: 80px;
      }

      .control-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
      }

      .control-btn.active {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      }

      .info-panel {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        min-width: 250px;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        z-index: 100;
      }

      .info-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(52, 152, 219, 0.2);
      }

      .info-label {
        font-weight: 500;
        color: #34495e;
        font-size: 14px;
      }

      .info-value {
        color: #2980b9;
        font-weight: 700;
        font-size: 14px;
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        text-align: center;
        z-index: 2000;
        display: none;
      }

      .loading.show {
        display: block;
      }

      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(46, 204, 113, 0.3);
        z-index: 2000;
        transform: translateX(400px);
        transition: transform 0.3s ease;
        font-weight: 600;
      }

      .toast.show {
        transform: translateX(0);
      }

      .toast.error {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        box-shadow: 0 8px 25px rgba(231, 76, 60, 0.3);
      }

      .error-state,
      .main-page {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f8f9fa;
        flex-direction: column;
        gap: 20px;
      }

      .error-icon,
      .welcome-icon {
        font-size: 72px;
        color: #e74c3c;
      }

      .welcome-icon {
        color: #3498db;
      }

      .error-text,
      .welcome-text {
        background: rgba(255, 255, 255, 0.9);
        padding: 20px 30px;
        border-radius: 12px;
        color: #e74c3c;
        font-weight: 600;
        text-align: center;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        max-width: 400px;
      }

      .welcome-text {
        color: #2c3e50;
      }

      .image-render {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f8f9fa;
        flex-direction: column;
        gap: 20px;
      }

      .image-render img {
        max-width: 90%;
        max-height: 80%;
        object-fit: contain;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      }

      .image-info {
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 8px;
        color: #2c3e50;
        font-weight: 600;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      }

      .toggle-switch {
        position: relative;
        width: 50px;
        height: 25px;
        background: #bdc3c7;
        border-radius: 25px;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .toggle-switch.active {
        background: #3498db;
      }

      .toggle-switch::after {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        width: 21px;
        height: 21px;
        background: white;
        border-radius: 50%;
        transition: transform 0.3s ease;
      }

      .toggle-switch.active::after {
        transform: translateX(25px);
      }

      .feature-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
    </style>
  </head>
  <body>
    <!-- Header -->
    <div class="header">
      <div class="logo">üîß EngTeklif 3D Viewer</div>
      <div class="header-controls">
        <button id="toggle-controls" class="btn secondary">
          üéÆ Kontroller
        </button>
        <button id="toggle-fullscreen" class="btn secondary">
          üì∫ Tam Ekran
        </button>
      </div>
    </div>

    <!-- Main Viewer Container -->
    <div id="viewer-container"></div>

    <!-- Control Panel -->
    <div id="control-panel" class="control-panel">
      <div class="control-section">
        <div class="section-title">üéÆ G√∂r√ºn√ºm Kontrolleri</div>
        <div class="control-row">
          <button id="reset-view" class="control-btn">üîÑ Sƒ±fƒ±rla</button>
          <button id="fit-view" class="control-btn">üìê Sƒ±ƒüdƒ±r</button>
        </div>
        <div class="control-row">
          <button id="front-view" class="control-btn">üìã √ñn</button>
          <button id="back-view" class="control-btn">üîô Arka</button>
          <button id="left-view" class="control-btn">‚¨ÖÔ∏è Sol</button>
          <button id="right-view" class="control-btn">‚û°Ô∏è Saƒü</button>
        </div>
        <div class="control-row">
          <button id="top-view" class="control-btn">‚¨ÜÔ∏è √úst</button>
          <button id="bottom-view" class="control-btn">‚¨áÔ∏è Alt</button>
          <button id="iso-view" class="control-btn">üéØ ƒ∞zometrik</button>
        </div>
      </div>

      <div class="control-section">
        <div class="section-title">üé® G√∂rsel Ayarlar</div>
        <div class="feature-toggle">
          <span>Wireframe:</span>
          <div id="wireframe-toggle" class="toggle-switch"></div>
        </div>
        <div class="feature-toggle">
          <span>G√∂lgeler:</span>
          <div id="shadows-toggle" class="toggle-switch active"></div>
        </div>
        <div class="feature-toggle">
          <span>Grid:</span>
          <div id="grid-toggle" class="toggle-switch"></div>
        </div>
        <div class="feature-toggle">
          <span>Eksenler:</span>
          <div id="axes-toggle" class="toggle-switch active"></div>
        </div>
      </div>

      <div class="control-section">
        <div class="section-title">üé® Malzeme</div>
        <div class="control-row">
          <button id="material-aluminum" class="control-btn">
            üîó Al√ºminyum
          </button>
          <button id="material-steel" class="control-btn">üî© √áelik</button>
          <button id="material-plastic" class="control-btn">üé® Plastik</button>
        </div>
      </div>
    </div>

    <!-- Info Panel -->
    <div id="info-panel" class="info-panel">
      <div class="section-title">üìä Model Bilgileri</div>
      <div id="model-info">
        <div class="info-row">
          <span class="info-label">Durum:</span>
          <span class="info-value" id="status-value">Y√ºkleniyor...</span>
        </div>
      </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading" class="loading">
      <div class="spinner"></div>
      <div id="loading-text">Model y√ºkleniyor...</div>
    </div>

    <!-- Toast Notifications -->
    <div id="toast" class="toast"></div>

    <script type="module">
      import * as THREE from "https://esm.sh/three@0.160.0";
      import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";
      import { STLLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/STLLoader.js";

      class EngTeklifSTEPViewer {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.model = null;
          this.lights = [];
          this.isLoading = false;
          this.currentAnalysisId = null;
          this.accessToken = null;

          this.init();
          this.setupEventListeners();
          this.checkForAnalysisId();
        }

        init() {
          // Scene setup
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0xf8f9fa);

          // Camera setup
          this.camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            10000
          );
          this.camera.position.set(150, 150, 150);

          // Renderer setup
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight - 60);
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.2;

          // Controls setup
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.screenSpacePanning = false;
          this.controls.minDistance = 10;
          this.controls.maxDistance = 1000;

          // Lighting setup
          this.setupLighting();

          // Grid and axes
          this.setupGridAndAxes();

          // Start render loop
          this.animate();
        }

        setupLighting() {
          // Ambient light
          const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
          this.scene.add(ambientLight);
          this.lights.push(ambientLight);

          // Directional light
          const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
          directionalLight.position.set(100, 100, 50);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 2048;
          directionalLight.shadow.mapSize.height = 2048;
          this.scene.add(directionalLight);
          this.lights.push(directionalLight);

          // Point lights
          const pointLight1 = new THREE.PointLight(0xffffff, 0.5, 300);
          pointLight1.position.set(-100, -100, 100);
          this.scene.add(pointLight1);
          this.lights.push(pointLight1);

          const pointLight2 = new THREE.PointLight(0xffffff, 0.3, 300);
          pointLight2.position.set(100, -100, -100);
          this.scene.add(pointLight2);
          this.lights.push(pointLight2);
        }

        setupGridAndAxes() {
          // Grid
          const gridHelper = new THREE.GridHelper(200, 20, 0x888888, 0xcccccc);
          gridHelper.name = "grid";
          this.scene.add(gridHelper);

          // Axes
          const axesHelper = new THREE.AxesHelper(50);
          axesHelper.name = "axes";
          this.scene.add(axesHelper);
        }

        setupEventListeners() {
          // Control buttons
          this.setupControlButtons();

          // Window resize
          window.addEventListener("resize", () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight - 60);
          });

          // Toggle panels
          document
            .getElementById("toggle-controls")
            .addEventListener("click", () => {
              document
                .getElementById("control-panel")
                .classList.toggle("visible");
            });

          // Fullscreen
          document
            .getElementById("toggle-fullscreen")
            .addEventListener("click", () => {
              if (document.fullscreenElement) {
                document.exitFullscreen();
              } else {
                document.documentElement.requestFullscreen();
              }
            });
        }

        setupControlButtons() {
          // View controls
          document
            .getElementById("reset-view")
            .addEventListener("click", () => {
              this.resetView();
            });

          document.getElementById("fit-view").addEventListener("click", () => {
            this.fitToView();
          });

          // Standard views
          document
            .getElementById("front-view")
            .addEventListener("click", () => {
              this.setStandardView("front");
            });

          document.getElementById("back-view").addEventListener("click", () => {
            this.setStandardView("back");
          });

          document.getElementById("left-view").addEventListener("click", () => {
            this.setStandardView("left");
          });

          document
            .getElementById("right-view")
            .addEventListener("click", () => {
              this.setStandardView("right");
            });

          document.getElementById("top-view").addEventListener("click", () => {
            this.setStandardView("top");
          });

          document
            .getElementById("bottom-view")
            .addEventListener("click", () => {
              this.setStandardView("bottom");
            });

          document.getElementById("iso-view").addEventListener("click", () => {
            this.setStandardView("isometric");
          });

          // Visual toggles
          this.setupToggle("wireframe-toggle", (active) => {
            if (this.model) {
              this.model.material.wireframe = active;
            }
          });

          this.setupToggle(
            "shadows-toggle",
            (active) => {
              this.renderer.shadowMap.enabled = active;
            },
            true
          );

          this.setupToggle("grid-toggle", (active) => {
            const grid = this.scene.getObjectByName("grid");
            if (grid) grid.visible = active;
          });

          this.setupToggle(
            "axes-toggle",
            (active) => {
              const axes = this.scene.getObjectByName("axes");
              if (axes) axes.visible = active;
            },
            true
          );

          // Material buttons
          document
            .getElementById("material-aluminum")
            .addEventListener("click", () => {
              this.setMaterial("aluminum");
            });

          document
            .getElementById("material-steel")
            .addEventListener("click", () => {
              this.setMaterial("steel");
            });

          document
            .getElementById("material-plastic")
            .addEventListener("click", () => {
              this.setMaterial("plastic");
            });
        }

        setupToggle(id, callback, initialState = false) {
          const toggle = document.getElementById(id);
          let active = initialState;

          if (initialState) {
            toggle.classList.add("active");
          }

          toggle.addEventListener("click", () => {
            active = !active;
            toggle.classList.toggle("active", active);
            callback(active);
          });
        }

        checkForAnalysisId() {
          // URL'den analysis_id ve access_token al
          const path = window.location.pathname;

          // Format 1: /step-viewer/{analysis_id}/{access_token}
          const fullMatch = path.match(/\/step-viewer\/([^\/]+)\/([^\/]+)$/);

          // Format 2: /step-viewer/{analysis_id}
          const simpleMatch = path.match(/\/step-viewer\/([^\/]+)$/);

          if (fullMatch) {
            // Token ile eri≈üim
            this.currentAnalysisId = fullMatch[1];
            this.accessToken = fullMatch[2];
            console.log(
              "[VIEWER] üîê Token ile eri≈üim:",
              this.currentAnalysisId
            );
            this.loadAnalysisModel(this.currentAnalysisId);
          } else if (simpleMatch) {
            // Sadece analysis_id ile eri≈üim
            this.currentAnalysisId = simpleMatch[1];
            this.accessToken = null;
            console.log("[VIEWER] üìã Basit eri≈üim:", this.currentAnalysisId);
            this.loadAnalysisModel(this.currentAnalysisId);
          } else {
            // Ana sayfa veya ge√ßersiz format
            console.log("[VIEWER] üè† Ana sayfa");
            this.showMainPage();
          }
        }

        async loadAnalysisModel(analysisId) {
          try {
            this.showLoading("3D model y√ºkleniyor...");

            const headers = {
              "Content-Type": "application/json",
            };

            if (this.accessToken) {
              headers["Authorization"] = `Bearer ${this.accessToken}`;
            }

            // 1. √ñNCE ANALƒ∞Z Bƒ∞LGƒ∞LERƒ∞Nƒ∞ AL
            console.log("[VIEWER] üì° Analiz bilgileri alƒ±nƒ±yor...");

            // Model bilgilerini kontrol et
            const modelInfoResponse = await fetch(
              `/api/upload/model-3d/${analysisId}`,
              {
                method: "GET",
                headers: headers,
              }
            );

            if (!modelInfoResponse.ok) {
              throw new Error(
                `Model bilgileri alƒ±namadƒ± (${modelInfoResponse.status})`
              );
            }

            const modelInfo = await modelInfoResponse.json();
            console.log("[VIEWER] üìä Model bilgileri:", modelInfo);

            // 2. STL DOSYASINI KONTROL ET
            let stlPath = null;

            if (
              modelInfo.success &&
              modelInfo.model_info.models_available.stl?.ready
            ) {
              stlPath = modelInfo.model_info.models_available.stl.path;
              console.log("[VIEWER] ‚úÖ STL dosyasƒ± mevcut:", stlPath);

              // PDF'den gelen √∂zel STL kontrol√º
              if (modelInfo.model_info.models_available.stl.from_pdf) {
                console.log("[VIEWER] üìÑ PDF'den √ßƒ±karƒ±lan STEP i√ßin STL");
              }

              try {
                await this.loadSTLFromPath(stlPath);

                // Analiz bilgilerini y√ºkle
                await this.loadAnalysisInfo(analysisId);

                this.showToast("3D model ba≈üarƒ±yla y√ºklendi!", "success");
                this.hideLoading();
                return;
              } catch (stlLoadError) {
                console.error("[VIEWER] ‚ùå STL y√ºkleme hatasƒ±:", stlLoadError);
                // STL y√ºklenemezse olu≈üturmayƒ± dene
              }
            }

            // 3. STL YOKSA VEYA Y√úKLENEMEDƒ∞YSE OLU≈ûTUR
            if (!stlPath || !modelInfo.model_info.models_available.stl?.ready) {
              console.log("[VIEWER] üîß STL olu≈üturuluyor...");
              this.showLoading("STL dosyasƒ± olu≈üturuluyor...");

              // √ñnce analiz edilmi≈ü mi kontrol et
              const analyzeResponse = await fetch(
                `/api/upload/analyze/${analysisId}`,
                {
                  method: "POST",
                  headers: headers,
                }
              );

              if (!analyzeResponse.ok) {
                console.error(
                  "[VIEWER] ‚ùå Analiz ba≈üarƒ±sƒ±z:",
                  analyzeResponse.status
                );
              } else {
                const analyzeResult = await analyzeResponse.json();
                console.log("[VIEWER] ‚úÖ Analiz tamamlandƒ±:", analyzeResult);
              }

              // STL olu≈ütur
              const generateResponse = await fetch(
                `/api/upload/generate-stl/${analysisId}`,
                {
                  method: "POST",
                  headers: headers,
                }
              );

              if (generateResponse.ok) {
                const generateResult = await generateResponse.json();
                console.log(
                  "[VIEWER] üì¶ STL olu≈üturma sonucu:",
                  generateResult
                );

                if (generateResult.success) {
                  console.log(
                    "[VIEWER] ‚úÖ STL olu≈üturuldu:",
                    generateResult.stl_path
                  );

                  try {
                    // Yeni STL path'i kullan
                    const newStlPath =
                      generateResult.stl_url || generateResult.stl_path;
                    console.log("[VIEWER] üîÑ Yeni STL y√ºkleniyor:", newStlPath);

                    await this.loadSTLFromPath(newStlPath);

                    // Analiz bilgilerini y√ºkle
                    await this.loadAnalysisInfo(analysisId);

                    this.showToast(
                      "3D model olu≈üturuldu ve y√ºklendi!",
                      "success"
                    );
                    this.hideLoading();
                    return;
                  } catch (stlLoadError) {
                    console.error(
                      "[VIEWER] ‚ùå Yeni STL y√ºkleme hatasƒ±:",
                      stlLoadError
                    );
                    throw stlLoadError;
                  }
                } else {
                  throw new Error(
                    generateResult.message || "STL olu≈üturulamadƒ±"
                  );
                }
              } else {
                const errorText = await generateResponse.text();
                console.error("[VIEWER] ‚ùå STL olu≈üturma isteƒüi ba≈üarƒ±sƒ±z:", {
                  status: generateResponse.status,
                  statusText: generateResponse.statusText,
                  error: errorText,
                });
                throw new Error(
                  `STL olu≈üturulamadƒ± (${generateResponse.status})`
                );
              }
            }
          } catch (error) {
            console.error("[VIEWER] ‚ùå Model y√ºkleme hatasƒ±:", error);
            this.showToast(`Model y√ºklenemedi: ${error.message}`, "error");
            this.showErrorState(error.message);
          } finally {
            this.hideLoading();
          }
        }

        async loadAnalysisInfo(analysisId) {
          try {
            const headers = {
              "Content-Type": "application/json",
            };

            if (this.accessToken) {
              headers["Authorization"] = `Bearer ${this.accessToken}`;
            }

            // Config endpoint'inden analiz bilgilerini al
            const configUrl = this.accessToken
              ? `/api/step-viewer/config/${analysisId}/${this.accessToken}`
              : `/api/step-viewer/config/${analysisId}`;

            const configResponse = await fetch(configUrl, {
              method: "GET",
              headers: headers,
            });

            if (configResponse.ok) {
              const configData = await configResponse.json();
              if (configData.success && configData.config) {
                // Analiz bilgilerini g√∂ster
                const analysis = {
                  original_filename:
                    configData.config.file_info.original_filename,
                  file_type: configData.config.file_info.file_type,
                  step_analysis: configData.config.step_analysis,
                  enhanced_renders: configData.config.enhanced_renders,
                };

                this.displayAnalysisInfo(analysis);
              }
            }
          } catch (error) {
            console.warn("[VIEWER] Analiz bilgileri y√ºklenemedi:", error);
          }
        }

        // STL y√ºkleme fonksiyonunu optimize et
        async loadSTLFromPath(stlPath) {
          return new Promise((resolve, reject) => {
            console.log("[STL-LOADER] üìÅ STL y√ºkleme ba≈ülƒ±yor:", stlPath);

            // Path'i normalize et
            if (!stlPath.startsWith("/")) {
              stlPath = "/" + stlPath;
            }

            console.log("[STL-LOADER] üìç Normalized path:", stlPath);

            const loader = new STLLoader();

            loader.load(
              stlPath,
              (geometry) => {
                try {
                  console.log("[STL-LOADER] ‚úÖ Geometry y√ºklendi:", {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index
                      ? geometry.index.count / 3
                      : "calculated",
                  });

                  this.processLoadedGeometry(geometry);
                  console.log("[STL-LOADER] ‚úÖ STL ba≈üarƒ±yla i≈ülendi");
                  resolve();
                } catch (error) {
                  console.error(
                    "[STL-LOADER] ‚ùå Geometry i≈üleme hatasƒ±:",
                    error
                  );
                  reject(error);
                }
              },
              (progress) => {
                if (progress.total > 0) {
                  const percent = Math.round(
                    (progress.loaded / progress.total) * 100
                  );
                  console.log(
                    `[STL-LOADER] üìä Y√ºkleme ilerlemesi: ${percent}% (${progress.loaded}/${progress.total})`
                  );
                  this.showLoading(`STL y√ºkleniyor... ${percent}%`);
                }
              },
              (error) => {
                console.error("[STL-LOADER] ‚ùå STL y√ºkleme hatasƒ±:", {
                  error: error,
                  path: stlPath,
                  errorType: error.type || "unknown",
                  message: error.message || error.toString(),
                });

                // Daha detaylƒ± hata mesajƒ±
                let errorMessage = "STL dosyasƒ± y√ºklenemedi";
                if (error.message) {
                  errorMessage += `: ${error.message}`;
                } else if (error.type === "load") {
                  errorMessage += " - Dosya bulunamadƒ± veya eri≈üilemiyor";
                }

                reject(new Error(errorMessage));
              }
            );
          });
        }

        async create3DModelFromJSON(analysisData) {
          try {
            this.showLoading("3D model olu≈üturuluyor...");

            const stepAnalysis = analysisData.step_analysis;

            if (!stepAnalysis || stepAnalysis.error) {
              throw new Error("STEP analiz verisi bulunamadƒ±");
            }

            // ‚úÖ JSON VERƒ∞Sƒ∞NDEN GEOMETRƒ∞ OLU≈ûTUR
            const geometry = this.createGeometryFromStepData(stepAnalysis);

            // Material olu≈ütur
            const material = new THREE.MeshPhongMaterial({
              color: 0x888888,
              shininess: 100,
              side: THREE.DoubleSide,
            });

            // Mevcut model'i kaldƒ±r
            if (this.model) {
              this.scene.remove(this.model);
            }

            // Yeni model olu≈ütur
            this.model = new THREE.Mesh(geometry, material);
            this.model.castShadow = true;
            this.model.receiveShadow = true;
            this.scene.add(this.model);

            // Kamerayƒ± ayarla
            this.fitToView();

            // Renderer'ƒ± container'a ekle
            const container = document.getElementById("viewer-container");
            container.innerHTML = "";
            container.appendChild(this.renderer.domElement);

            console.log("[VIEWER] ‚úÖ 3D model JSON'dan olu≈üturuldu");
          } catch (error) {
            console.error(
              "[VIEWER] ‚ùå JSON'dan model olu≈üturma hatasƒ±:",
              error
            );
            throw error;
          }
        }

        createGeometryFromStepData(stepData) {
          try {
            // STEP analiz verisinden boyutlarƒ± al
            const width = stepData["X (mm)"] || 50;
            const height = stepData["Y (mm)"] || 30;
            const depth = stepData["Z (mm)"] || 20;

            console.log(
              `[GEOMETRY] üìê Boyutlar: ${width}x${height}x${depth} mm`
            );

            // ‚úÖ METHOD 1: BufferGeometry ile manuel olu≈ütur
            if (stepData.method === "cadquery_analysis") {
              return this.createDetailedGeometry(
                width,
                height,
                depth,
                stepData
              );
            } else {
              // ‚úÖ METHOD 2: Basit box geometry (fallback)
              return this.createSimpleBoxGeometry(width, height, depth);
            }
          } catch (error) {
            console.error("[GEOMETRY] ‚ùå Geometry olu≈üturma hatasƒ±:", error);
            // Fallback: 50x30x20 mm box
            return this.createSimpleBoxGeometry(50, 30, 20);
          }
        }

        createDetailedGeometry(width, height, depth, stepData) {
          try {
            console.log("[GEOMETRY] üîß Detaylƒ± geometry olu≈üturuluyor...");

            // ‚úÖ BOUNDING BOX VERTICES (8 k√∂≈üe noktasƒ±)
            const halfW = width / 2;
            const halfH = height / 2;
            const halfD = depth / 2;

            const vertices = new Float32Array([
              // Front face (z = +halfD)
              -halfW,
              -halfH,
              halfD, // 0: bottom-left
              halfW,
              -halfH,
              halfD, // 1: bottom-right
              halfW,
              halfH,
              halfD, // 2: top-right
              -halfW,
              halfH,
              halfD, // 3: top-left

              // Back face (z = -halfD)
              -halfW,
              -halfH,
              -halfD, // 4: bottom-left
              halfW,
              -halfH,
              -halfD, // 5: bottom-right
              halfW,
              halfH,
              -halfD, // 6: top-right
              -halfW,
              halfH,
              -halfD, // 7: top-left
            ]);

            // ‚úÖ TRIANGLE FACES (2 triangles per face = 12 triangles total)
            const indices = new Uint16Array([
              // Front face
              0, 1, 2, 0, 2, 3,
              // Back face
              4, 6, 5, 4, 7, 6,
              // Left face
              4, 0, 3, 4, 3, 7,
              // Right face
              1, 5, 6, 1, 6, 2,
              // Top face
              3, 2, 6, 3, 6, 7,
              // Bottom face
              4, 5, 1, 4, 1, 0,
            ]);

            // BufferGeometry olu≈ütur
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute(
              "position",
              new THREE.BufferAttribute(vertices, 3)
            );
            geometry.setIndex(indices);

            // Normals hesapla
            geometry.computeVertexNormals();
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();

            console.log(
              `[GEOMETRY] ‚úÖ Detaylƒ± geometry: ${
                vertices.length / 3
              } vertices, ${indices.length / 3} faces`
            );

            return geometry;
          } catch (error) {
            console.error("[GEOMETRY] ‚ùå Detaylƒ± geometry hatasƒ±:", error);
            return this.createSimpleBoxGeometry(width, height, depth);
          }
        }

        createSimpleBoxGeometry(width, height, depth) {
          console.log(
            `[GEOMETRY] üì¶ Basit box geometry: ${width}x${height}x${depth}`
          );
          return new THREE.BoxGeometry(width, height, depth);
        }

        async trySTLFallback(analysisId) {
          try {
            console.log("[FALLBACK] üîÑ STL fallback deneniyor...");
            const stlPath = `/static/stepviews/${analysisId}/model_${analysisId}.stl`;
            await this.loadSTLFromPath(stlPath);
            this.showToast("STL dosyasƒ±ndan y√ºklendi", "success");
          } catch (stlError) {
            console.error("[FALLBACK] ‚ùå STL fallback ba≈üarƒ±sƒ±z:", stlError);
            this.showErrorState(
              "Model y√ºklenemedi - JSON ve STL y√ºkleme ba≈üarƒ±sƒ±z"
            );
          }
        }

        async loadSTLFromPath(stlPath) {
          return new Promise((resolve, reject) => {
            const loader = new STLLoader();

            loader.load(
              stlPath,
              (geometry) => {
                try {
                  this.processLoadedGeometry(geometry);
                  resolve();
                } catch (error) {
                  reject(error);
                }
              },
              (progress) => {
                const percent = Math.round(
                  (progress.loaded / progress.total) * 100
                );
                this.showLoading(`STL y√ºkleniyor... ${percent}%`);
              },
              (error) => {
                reject(new Error("STL dosyasƒ± y√ºklenemedi"));
              }
            );
          });
        }

        processLoadedGeometry(geometry) {
          // STL geometry i≈üleme
          geometry.computeVertexNormals();
          geometry.computeBoundingBox();

          const center = new THREE.Vector3();
          geometry.boundingBox.getCenter(center);
          geometry.translate(-center.x, -center.y, -center.z);

          const material = new THREE.MeshPhongMaterial({
            color: 0x888888,
            shininess: 100,
            side: THREE.DoubleSide,
          });

          if (this.model) {
            this.scene.remove(this.model);
          }

          this.model = new THREE.Mesh(geometry, material);
          this.model.castShadow = true;
          this.model.receiveShadow = true;
          this.scene.add(this.model);

          this.fitToView();

          const container = document.getElementById("viewer-container");
          container.innerHTML = "";
          container.appendChild(this.renderer.domElement);
        }

        displayAnalysisInfo(analysis) {
          const analysisDetails = document.getElementById("model-info");
          const stepAnalysis = analysis.step_analysis || {};

          let detailsHTML = `
            <div class="info-row">
              <span class="info-label">Durum:</span>
              <span class="info-value" style="color: #27ae60;">JSON'dan Olu≈üturuldu</span>
            </div>
            <div class="info-row">
              <span class="info-label">Dosya:</span>
              <span class="info-value">${
                analysis.original_filename || "Bilinmeyen"
              }</span>
            </div>
            <div class="info-row">
              <span class="info-label">Y√∂ntem:</span>
              <span class="info-value">JSON Geometry</span>
            </div>
          `;

          if (stepAnalysis["X (mm)"]) {
            const volume = stepAnalysis["Prizma Hacmi (mm¬≥)"] || 0;
            const surfaceArea = stepAnalysis["Toplam Y√ºzey Alanƒ± (mm¬≤)"] || 0;

            detailsHTML += `
              <div class="info-row">
                <span class="info-label">Geni≈ülik:</span>
                <span class="info-value">${stepAnalysis["X (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Y√ºkseklik:</span>
                <span class="info-value">${stepAnalysis["Y (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Derinlik:</span>
                <span class="info-value">${stepAnalysis["Z (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Hacim:</span>
                <span class="info-value">${volume.toLocaleString()} mm¬≥</span>
              </div>
              <div class="info-row">
                <span class="info-label">Y√ºzey:</span>
                <span class="info-value">${surfaceArea.toLocaleString()} mm¬≤</span>
              </div>
              <div class="info-row">
                <span class="info-label">Metod:</span>
                <span class="info-value">${
                  stepAnalysis.method || "Unknown"
                }</span>
              </div>
            `;
          }

          // Malzeme bilgileri
          if (
            analysis.material_matches &&
            analysis.material_matches.length > 0
          ) {
            const materials = analysis.material_matches.slice(0, 3);
            detailsHTML += `
              <div class="info-row">
                <span class="info-label">Malzemeler:</span>
                <span class="info-value">${materials.length} adet</span>
              </div>
            `;

            materials.forEach((material, index) => {
              const materialName = material.split("(")[0].trim();
              detailsHTML += `
                <div class="info-row">
                  <span class="info-label">‚Ä¢ ${materialName}:</span>
                  <span class="info-value" style="font-size: 11px;">${
                    material.includes("%100") ? "Kesin" : "Tahmini"
                  }</span>
                </div>
              `;
            });
          }

          analysisDetails.innerHTML = detailsHTML;
        }

        showMainPage() {
          // Ana sayfa g√∂sterimi
          const container = document.getElementById("viewer-container");

          const mainPageContainer = document.createElement("div");
          mainPageContainer.className = "main-page";

          const welcomeIcon = document.createElement("div");
          welcomeIcon.className = "welcome-icon";
          welcomeIcon.textContent = "üéØ";

          const welcomeText = document.createElement("div");
          welcomeText.className = "welcome-text";
          welcomeText.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 15px; color: #3498db;">üîß EngTeklif 3D Viewer</div>
                    <div style="font-size: 16px; margin-bottom: 20px;">3D STEP model g√∂r√ºnt√ºleyici</div>
                    <div style="font-size: 14px; color: #7f8c8d; line-height: 1.6;">
                        Model g√∂r√ºnt√ºlemek i√ßin doƒüru URL formatƒ±nƒ± kullanƒ±n:<br><br>
                        üìã <strong>/step-viewer/{analysis_id}</strong><br>
                        üîê <strong>/step-viewer/{analysis_id}/{access_token}</strong>
                    </div>
                `;

          const uploadButton = document.createElement("button");
          uploadButton.className = "btn";
          uploadButton.innerHTML = "üìÅ Dosya Y√ºkle";
          uploadButton.onclick = () => {
            window.location.href = "/api/upload/supported-formats";
          };

          mainPageContainer.appendChild(welcomeIcon);
          mainPageContainer.appendChild(welcomeText);
          mainPageContainer.appendChild(uploadButton);
          container.innerHTML = "";
          container.appendChild(mainPageContainer);

          // Status'u g√ºncelle
          document.getElementById("status-value").textContent = "Hazƒ±r";
          document.getElementById("status-value").style.color = "#27ae60";
        }

        showErrorState(message) {
          const container = document.getElementById("viewer-container");

          const errorContainer = document.createElement("div");
          errorContainer.className = "error-state";

          const errorIcon = document.createElement("div");
          errorIcon.className = "error-icon";
          errorIcon.textContent = "‚ö†Ô∏è";

          const errorText = document.createElement("div");
          errorText.className = "error-text";
          errorText.innerHTML = `
                    <div style="font-size: 18px; margin-bottom: 10px;">Model Y√ºklenemedi</div>
                    <div style="font-size: 14px; color: #7f8c8d;">${message}</div>
                `;

          const backButton = document.createElement("button");
          backButton.className = "btn";
          backButton.textContent = "üè† Ana Sayfaya D√∂n";
          backButton.onclick = () => {
            window.location.href = "/step-viewer";
          };

          errorContainer.appendChild(errorIcon);
          errorContainer.appendChild(errorText);
          errorContainer.appendChild(backButton);
          container.innerHTML = "";
          container.appendChild(errorContainer);
        }

        resetView() {
          if (this.model) {
            this.camera.position.set(150, 150, 150);
            this.camera.lookAt(0, 0, 0);
            this.controls.target.set(0, 0, 0);
            this.controls.update();
          }
        }

        fitToView() {
          if (this.model) {
            const box = new THREE.Box3().setFromObject(this.model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = this.camera.fov * (Math.PI / 180);
            const cameraDistance =
              Math.abs(maxDim / (2 * Math.tan(fov / 2))) * 1.5;

            this.camera.position.copy(center);
            this.camera.position.x += cameraDistance * 0.8;
            this.camera.position.y += cameraDistance * 0.6;
            this.camera.position.z += cameraDistance * 0.8;

            this.camera.lookAt(center);
            this.controls.target.copy(center);
            this.controls.update();
          }
        }

        setStandardView(viewType) {
          if (!this.model) return;

          const box = new THREE.Box3().setFromObject(this.model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const distance = maxDim * 2;

          const positions = {
            front: [center.x, center.y, center.z + distance],
            back: [center.x, center.y, center.z - distance],
            left: [center.x - distance, center.y, center.z],
            right: [center.x + distance, center.y, center.z],
            top: [center.x, center.y + distance, center.z],
            bottom: [center.x, center.y - distance, center.z],
            isometric: [
              center.x + distance * 0.7,
              center.y + distance * 0.7,
              center.z + distance * 0.7,
            ],
          };

          const position = positions[viewType];
          if (position) {
            this.camera.position.set(...position);
            this.camera.lookAt(center);
            this.controls.target.copy(center);
            this.controls.update();
          }
        }

        setMaterial(materialType) {
          if (!this.model) return;

          const materials = {
            aluminum: { color: 0xc0c0c0, shininess: 100 },
            steel: { color: 0x708090, shininess: 80 },
            plastic: { color: 0x4a90e2, shininess: 30 },
          };

          const materialConfig = materials[materialType];
          if (materialConfig) {
            this.model.material.color.setHex(materialConfig.color);
            this.model.material.shininess = materialConfig.shininess;
          }
        }

        showLoading(message = "Y√ºkleniyor...") {
          const loading = document.getElementById("loading");
          const loadingText = document.getElementById("loading-text");
          loadingText.textContent = message;
          loading.classList.add("show");
          this.isLoading = true;
        }

        hideLoading() {
          document.getElementById("loading").classList.remove("show");
          this.isLoading = false;
        }

        showToast(message, type = "success") {
          const toast = document.getElementById("toast");
          toast.textContent = message;
          toast.className = `toast ${type}`;
          toast.classList.add("show");

          setTimeout(() => {
            toast.classList.remove("show");
          }, 3000);
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          if (this.controls) {
            this.controls.update();
          }

          if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
          }
        }
      }

      // Initialize the viewer
      window.addEventListener("DOMContentLoaded", () => {
        new EngTeklifSTEPViewer();
      });
    </script>
  </body>
</html>
