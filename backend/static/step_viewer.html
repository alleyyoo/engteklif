<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EngTeklif 3D STEP Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", "Segoe UI", Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #2c3e50;
        overflow: hidden;
        height: 100vh;
      }

      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid rgba(52, 152, 219, 0.2);
        display: flex;
        align-items: center;
        padding: 0 20px;
        z-index: 1000;
        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
      }

      .logo {
        font-weight: 800;
        font-size: 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .header-controls {
        margin-left: auto;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 12px;
        padding: 10px 16px;
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
      }

      .btn.secondary {
        background: rgba(255, 255, 255, 0.9);
        color: #667eea;
        border: 2px solid #667eea;
      }

      #viewer-container {
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 0;
        background: #f8f9fa;
      }

      .control-panel {
        position: fixed;
        top: 80px;
        left: 20px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        min-width: 280px;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        z-index: 100;
        transform: translateX(-320px);
        transition: transform 0.3s ease;
        display: none;
      }

      .control-panel.visible {
        transform: translateX(0);
        display: block;
      }

      .control-section {
        margin-bottom: 20px;
      }

      .section-title {
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 12px;
        font-size: 16px;
        border-bottom: 2px solid #3498db;
        padding-bottom: 6px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .control-row {
        display: flex;
        gap: 8px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      .control-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 8px 14px;
        cursor: pointer;
        font-family: inherit;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.3s ease;
        flex: 1;
        min-width: 80px;
      }

      .control-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
      }

      .control-btn.active {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      }

      .info-panel {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        min-width: 250px;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        z-index: 100;
      }

      .info-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(52, 152, 219, 0.2);
      }

      .info-label {
        font-weight: 500;
        color: #34495e;
        font-size: 14px;
      }

      .info-value {
        color: #2980b9;
        font-weight: 700;
        font-size: 14px;
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        text-align: center;
        z-index: 2000;
        display: none;
      }

      .loading.show {
        display: block;
      }

      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(46, 204, 113, 0.3);
        z-index: 2000;
        transform: translateX(400px);
        transition: transform 0.3s ease;
        font-weight: 600;
      }

      .toast.show {
        transform: translateX(0);
      }

      .toast.error {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        box-shadow: 0 8px 25px rgba(231, 76, 60, 0.3);
      }

      .error-state,
      .main-page {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f8f9fa;
        flex-direction: column;
        gap: 20px;
      }

      .error-icon,
      .welcome-icon {
        font-size: 72px;
        color: #e74c3c;
      }

      .welcome-icon {
        color: #3498db;
      }

      .error-text,
      .welcome-text {
        background: rgba(255, 255, 255, 0.9);
        padding: 20px 30px;
        border-radius: 12px;
        color: #e74c3c;
        font-weight: 600;
        text-align: center;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        max-width: 400px;
      }

      .welcome-text {
        color: #2c3e50;
      }

      .image-render {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f8f9fa;
        flex-direction: column;
        gap: 20px;
      }

      .image-render img {
        max-width: 90%;
        max-height: 80%;
        object-fit: contain;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      }

      .image-info {
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 8px;
        color: #2c3e50;
        font-weight: 600;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      }

      .toggle-switch {
        position: relative;
        width: 50px;
        height: 25px;
        background: #bdc3c7;
        border-radius: 25px;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .toggle-switch.active {
        background: #3498db;
      }

      .toggle-switch::after {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        width: 21px;
        height: 21px;
        background: white;
        border-radius: 50%;
        transition: transform 0.3s ease;
      }

      .toggle-switch.active::after {
        transform: translateX(25px);
      }

      .feature-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }

      /* Measurement popup styles */
      #distance-popup {
        position: absolute;
        top: 520px;
        right: 24px;
        left: auto;
        transform: none;
        background: #f8fafc;
        border-radius: 15px;
        padding: 22px 28px 18px 28px;
        box-shadow: 0 6px 28px rgba(60, 72, 90, 0.11);
        font-family: inherit;
        font-size: 0.97rem;
        color: #205087;
        z-index: 20;
        transition: opacity 0.3s ease;
        min-width: 210px;
        display: none;
      }

      #popup-content {
        position: relative;
        padding-top: 6px;
      }

      #popup-close {
        position: absolute;
        top: -13px;
        right: -13px;
        background: #eaf1fb;
        color: #205087;
        border-radius: 999px;
        padding: 4px 10px 4px 10px;
        cursor: pointer;
        font-weight: 600;
        font-size: 17px;
        line-height: 20px;
        box-shadow: 0 0 6px rgba(60, 72, 90, 0.12);
        border: 1.5px solid #eaf1fb;
        transition: background 0.12s;
      }

      #popup-close:hover {
        background: #dbeafb;
      }
    </style>
  </head>
  <body>
    <!-- Header -->
    <div class="header">
      <div class="logo">üîß EngTeklif 3D Viewer</div>
      <div class="header-controls">
        <button id="toggle-controls" class="btn secondary">
          üéÆ Kontroller
        </button>
        <button id="measure-btn" class="btn secondary">üìè √ñl√ß√ºm</button>
        <button id="toggle-fullscreen" class="btn secondary">
          üì∫ Tam Ekran
        </button>
      </div>
    </div>

    <!-- Main Viewer Container -->
    <div id="viewer-container"></div>

    <!-- Control Panel -->
    <div id="control-panel" class="control-panel visible">
      <div class="control-section">
        <div class="section-title">üéÆ G√∂r√ºn√ºm Kontrolleri</div>
        <div class="control-row">
          <button id="reset-view" class="control-btn">üîÑ Sƒ±fƒ±rla</button>
          <button id="fit-view" class="control-btn">üìê Sƒ±ƒüdƒ±r</button>
        </div>
        <div class="control-row">
          <button id="front-view" class="control-btn">üìã √ñn</button>
          <button id="back-view" class="control-btn">üîô Arka</button>
          <button id="left-view" class="control-btn">‚¨ÖÔ∏è Sol</button>
          <button id="right-view" class="control-btn">‚û°Ô∏è Saƒü</button>
        </div>
        <div class="control-row">
          <button id="top-view" class="control-btn">‚¨ÜÔ∏è √úst</button>
          <button id="bottom-view" class="control-btn">‚¨áÔ∏è Alt</button>
          <button id="iso-view" class="control-btn">üéØ ƒ∞zometrik</button>
        </div>
      </div>

      <div class="control-section">
        <div class="section-title">üé® G√∂rsel Ayarlar</div>
        <div class="feature-toggle">
          <span>Wireframe:</span>
          <div id="wireframe-toggle" class="toggle-switch"></div>
        </div>
        <div class="feature-toggle">
          <span>G√∂lgeler:</span>
          <div id="shadows-toggle" class="toggle-switch active"></div>
        </div>
        <div class="feature-toggle">
          <span>Grid:</span>
          <div id="grid-toggle" class="toggle-switch"></div>
        </div>
        <div class="feature-toggle">
          <span>Eksenler:</span>
          <div id="axes-toggle" class="toggle-switch active"></div>
        </div>
        <div class="feature-toggle">
          <span>Prizma:</span>
          <div id="bbox-toggle" class="toggle-switch"></div>
        </div>
      </div>

      <div class="control-section">
        <div class="section-title">üé® Renk Modu</div>
        <div class="control-row">
          <button id="vertex-color-btn" class="control-btn">
            üåà Vertex Renk
          </button>
          <button id="solid-color-btn" class="control-btn active">
            üé® D√ºz Gri
          </button>
        </div>
      </div>

      <div class="control-section">
        <div class="section-title">üé® Malzeme</div>
        <div class="control-row">
          <button id="material-aluminum" class="control-btn">
            üîó Al√ºminyum
          </button>
          <button id="material-steel" class="control-btn">üî© √áelik</button>
          <button id="material-plastic" class="control-btn">üé® Plastik</button>
        </div>
      </div>
    </div>

    <!-- Info Panel -->
    <div id="info-panel" class="info-panel">
      <div class="section-title">üìä Model Bilgileri</div>
      <div id="model-info">
        <div class="info-row">
          <span class="info-label">Durum:</span>
          <span class="info-value" id="status-value">Y√ºkleniyor...</span>
        </div>
      </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading" class="loading">
      <div class="spinner"></div>
      <div id="loading-text">Model y√ºkleniyor...</div>
    </div>

    <!-- Toast Notifications -->
    <div id="toast" class="toast"></div>

    <!-- Distance Measurement Popup -->
    <div id="distance-popup">
      <div id="popup-content">
        <span id="popup-close">&times;</span>
        <p id="popup-text"></p>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://esm.sh/three@0.176.0";
      import { OrbitControls } from "https://esm.sh/three@0.176.0/examples/jsm/controls/OrbitControls.js";
      import { STLLoader } from "https://esm.sh/three@0.176.0/examples/jsm/loaders/STLLoader.js";

      class EngTeklifSTEPViewer {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.model = null;
          this.lights = [];
          this.isLoading = false;
          this.currentAnalysisId = null;
          this.accessToken = null;
          this.currentColorMode = "solid";
          this.measurementMode = false;
          this.selectedPoints = [];
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.mouse3D = new THREE.Vector3();

          this.init();
          this.setupEventListeners();
          this.checkForAnalysisId();
        }

        init() {
          // Scene setup
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0xf4f4f4);

          // Camera setup
          this.camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            1,
            1000
          );
          this.camera.position.set(50, 50, 50);

          // Renderer setup
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight - 60);
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.2;

          // Controls setup
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.screenSpacePanning = false;
          this.controls.minDistance = 10;
          this.controls.maxDistance = 1000;

          // Lighting setup
          this.setupLighting();

          // Grid and axes
          this.setupGridAndAxes();

          // Start render loop
          this.animate();
        }

        setupLighting() {
          // Enhanced lighting similar to original
          const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
          light1.position.set(1, 1, 1);
          this.scene.add(light1);

          const light2 = new THREE.AmbientLight(0xffffff, 0.2);
          this.scene.add(light2);

          const light3 = new THREE.DirectionalLight(0xffffff, 0.5);
          light3.position.set(0, -1, 0);
          this.scene.add(light3);

          const lightZ1 = new THREE.DirectionalLight(0xffffff, 0.4);
          lightZ1.position.set(0, 0, 1);
          this.scene.add(lightZ1);

          const lightZ2 = new THREE.DirectionalLight(0xffffff, 0.4);
          lightZ2.position.set(0, 0, -1);
          this.scene.add(lightZ2);

          const lightX1 = new THREE.DirectionalLight(0xffffff, 0.25);
          lightX1.position.set(1, 0, 0);
          this.scene.add(lightX1);

          const lightX2 = new THREE.DirectionalLight(0xffffff, 0.25);
          lightX2.position.set(-1, 0, 0);
          this.scene.add(lightX2);

          const topLight = new THREE.DirectionalLight(0xffffff, 0.9);
          topLight.position.set(0, 1, 0);
          this.scene.add(topLight);

          const sideLight1 = new THREE.DirectionalLight(0xffffff, 0.4);
          sideLight1.position.set(1, 0.5, 0.5);
          this.scene.add(sideLight1);

          const sideLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
          sideLight2.position.set(-1, 0.5, -0.5);
          this.scene.add(sideLight2);
        }

        setupGridAndAxes() {
          // Grid
          const gridHelper = new THREE.GridHelper(200, 50);
          gridHelper.name = "grid";
          gridHelper.visible = false;
          this.scene.add(gridHelper);

          // Axes
          const axesHelper = new THREE.AxesHelper(50);
          axesHelper.name = "axes";
          this.scene.add(axesHelper);
        }

        setupEventListeners() {
          this.setupControlButtons();
          this.setupMeasurement();

          // Window resize
          window.addEventListener("resize", () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight - 60);
          });

          // Toggle panels
          document
            .getElementById("toggle-controls")
            .addEventListener("click", () => {
              document
                .getElementById("control-panel")
                .classList.toggle("visible");
            });

          // Fullscreen
          document
            .getElementById("toggle-fullscreen")
            .addEventListener("click", () => {
              if (document.fullscreenElement) {
                document.exitFullscreen();
              } else {
                document.documentElement.requestFullscreen();
              }
            });
        }

        setupMeasurement() {
          // Measurement button
          const measureBtn = document.getElementById("measure-btn");
          measureBtn.addEventListener("click", () => {
            this.measurementMode = !this.measurementMode;
            measureBtn.classList.toggle("active", this.measurementMode);

            // Update button text and style
            if (this.measurementMode) {
              measureBtn.style.background =
                "linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)";
              measureBtn.textContent = "üìè √ñl√ß√ºm Aktif";
            } else {
              measureBtn.style.background = "";
              measureBtn.textContent = "üìè √ñl√ß√ºm";
              this.clearMeasurements();
            }
          });

          // Close popup handler
          document
            .getElementById("popup-close")
            .addEventListener("click", () => {
              document.getElementById("distance-popup").style.display = "none";
              this.clearMeasurements();
            });
        }

        setupMeasurementEvents() {
          // Remove existing event listeners to avoid duplicates
          if (this.measurementEventsSetup) return;

          // Mouse events for measurement
          this.renderer.domElement.addEventListener("mousemove", (event) => {
            if (
              this.measurementMode &&
              this.selectedPoints.length === 1 &&
              this.model
            ) {
              // Calculate mouse position relative to the renderer canvas
              const rect = this.renderer.domElement.getBoundingClientRect();
              this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
              this.mouse.y =
                -((event.clientY - rect.top) / rect.height) * 2 + 1;

              this.raycaster.setFromCamera(this.mouse, this.camera);
              const intersects = this.raycaster.intersectObject(
                this.model,
                true
              );
              if (intersects.length > 0) {
                this.mouse3D.copy(intersects[0].point);
              }
            }
          });

          this.renderer.domElement.addEventListener("click", (event) => {
            this.onClick(event);
          });

          this.measurementEventsSetup = true;
        }

        onClick(event) {
          if (
            document.getElementById("distance-popup").style.display === "block"
          )
            return;
          if (!this.model || !this.measurementMode) return;

          // Calculate mouse position relative to the renderer canvas
          const rect = this.renderer.domElement.getBoundingClientRect();
          this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, this.camera);
          const intersects = this.raycaster.intersectObject(this.model, true);

          if (intersects.length > 0) {
            const point = intersects[0].point.clone();
            this.selectedPoints.push(point);

            // Add marker
            const marker = new THREE.Mesh(
              new THREE.SphereGeometry(0.5), // Larger marker for visibility
              new THREE.MeshBasicMaterial({ color: 0xff6666 })
            );
            marker.position.copy(point);
            this.scene.add(marker);
            if (!window._currentMarkers) window._currentMarkers = [];
            window._currentMarkers.push(marker);

            console.log(
              `Measurement point ${this.selectedPoints.length} added:`,
              point
            );

            if (this.selectedPoints.length === 1) {
              // Create preview line
              this.createPreviewLine();
              this.showToast("ƒ∞kinci noktayƒ± se√ßin", "info");
            }

            if (this.selectedPoints.length === 2) {
              this.showDistance();
              this.showToast("Mesafe √∂l√ß√ºld√º!", "success");
            }
          }
        }

        createPreviewLine() {
          if (window._previewLine) {
            this.scene.remove(window._previewLine);
            window._previewLine = null;
          }

          const dynamicLineGeometry = new THREE.BufferGeometry().setFromPoints([
            this.selectedPoints[0],
            this.selectedPoints[0].clone(),
          ]);

          const dynamicLine = new THREE.Line(
            dynamicLineGeometry,
            new THREE.LineDashedMaterial({
              color: 0xff0000,
              dashSize: 0.2,
              gapSize: 0.1,
            })
          );

          this.scene.add(dynamicLine);
          window._previewLine = dynamicLine;
        }

        showDistance() {
          const geometry = new THREE.BufferGeometry().setFromPoints(
            this.selectedPoints
          );
          const line = new THREE.Line(
            geometry,
            new THREE.LineBasicMaterial({ color: 0x0000ff })
          );
          this.scene.add(line);

          const distance = this.selectedPoints[0].distanceTo(
            this.selectedPoints[1]
          );
          const popup = document.getElementById("distance-popup");
          const popupText = document.getElementById("popup-text");
          popupText.textContent = `Mesafe: ${distance.toFixed(2)} birim`;
          popup.style.display = "block";

          window._currentLine = line;

          if (window._previewLine) {
            this.scene.remove(window._previewLine);
            window._previewLine = null;
          }
        }

        clearMeasurements() {
          console.log("Clearing measurements...");

          if (window._currentMarkers) {
            window._currentMarkers.forEach((m) => this.scene.remove(m));
            window._currentMarkers = [];
          }
          if (window._currentLine) {
            this.scene.remove(window._currentLine);
            window._currentLine = null;
          }
          if (window._previewLine) {
            this.scene.remove(window._previewLine);
            window._previewLine = null;
          }
          this.selectedPoints = [];

          // Update button style
          const measureBtn = document.getElementById("measure-btn");
          if (measureBtn && !this.measurementMode) {
            measureBtn.style.background = "";
            measureBtn.textContent = "üìè √ñl√ß√ºm";
          }
        }

        setupControlButtons() {
          // View controls
          document
            .getElementById("reset-view")
            .addEventListener("click", () => {
              this.resetView();
            });

          document.getElementById("fit-view").addEventListener("click", () => {
            this.fitToView();
          });

          // Standard views
          document
            .getElementById("front-view")
            .addEventListener("click", () => {
              this.setStandardView("front");
            });

          document.getElementById("back-view").addEventListener("click", () => {
            this.setStandardView("back");
          });

          document.getElementById("left-view").addEventListener("click", () => {
            this.setStandardView("left");
          });

          document
            .getElementById("right-view")
            .addEventListener("click", () => {
              this.setStandardView("right");
            });

          document.getElementById("top-view").addEventListener("click", () => {
            this.setStandardView("top");
          });

          document
            .getElementById("bottom-view")
            .addEventListener("click", () => {
              this.setStandardView("bottom");
            });

          document.getElementById("iso-view").addEventListener("click", () => {
            this.setStandardView("isometric");
          });

          // Color mode buttons
          document
            .getElementById("vertex-color-btn")
            .addEventListener("click", () => {
              this.setColorMode("vertex");
            });

          document
            .getElementById("solid-color-btn")
            .addEventListener("click", () => {
              this.setColorMode("solid");
            });

          // Visual toggles
          this.setupToggle("wireframe-toggle", (active) => {
            if (this.model) {
              this.model.material.wireframe = active;
            }
          });

          this.setupToggle(
            "shadows-toggle",
            (active) => {
              this.renderer.shadowMap.enabled = active;
            },
            true
          );

          this.setupToggle("grid-toggle", (active) => {
            const grid = this.scene.getObjectByName("grid");
            if (grid) grid.visible = active;
          });

          this.setupToggle(
            "axes-toggle",
            (active) => {
              const axes = this.scene.getObjectByName("axes");
              if (axes) axes.visible = active;
            },
            true
          );

          this.setupToggle("bbox-toggle", (active) => {
            this.toggleBoundingBox(active);
          });

          // Material buttons
          document
            .getElementById("material-aluminum")
            .addEventListener("click", () => {
              this.setMaterial("aluminum");
            });

          document
            .getElementById("material-steel")
            .addEventListener("click", () => {
              this.setMaterial("steel");
            });

          document
            .getElementById("material-plastic")
            .addEventListener("click", () => {
              this.setMaterial("plastic");
            });
        }

        setColorMode(mode) {
          if (mode === this.currentColorMode) return;

          this.currentColorMode = mode;

          // Update button states
          document
            .querySelectorAll("#vertex-color-btn, #solid-color-btn")
            .forEach((btn) => {
              btn.classList.remove("active");
            });

          if (mode === "vertex") {
            document.getElementById("vertex-color-btn").classList.add("active");
          } else {
            document.getElementById("solid-color-btn").classList.add("active");
          }

          // Reload model with new color mode
          if (this.model && this.currentAnalysisId) {
            this.reloadModelWithColorMode(mode);
          }
        }

        async reloadModelWithColorMode(mode) {
          try {
            const modelPath = `/static/stepviews/${this.currentAnalysisId}/model_${this.currentAnalysisId}.stl`;

            const loader = new STLLoader();
            loader.load(modelPath, (geometry) => {
              geometry.computeVertexNormals();

              let material;
              if (mode === "vertex") {
                const colors = [];
                const position = geometry.attributes.position;
                for (let i = 0; i < position.count; i++) {
                  const y = position.getY(i);
                  const color = new THREE.Color().setHSL(
                    (y + 50) / 100,
                    1.0,
                    0.5
                  );
                  colors.push(color.r, color.g, color.b);
                }
                geometry.setAttribute(
                  "color",
                  new THREE.Float32BufferAttribute(colors, 3)
                );
                material = new THREE.MeshPhongMaterial({
                  vertexColors: true,
                  side: THREE.DoubleSide,
                  shininess: 100,
                });
              } else {
                material = new THREE.MeshPhongMaterial({
                  color: 0xb0bec5,
                  shininess: 25,
                  specular: 0x222222,
                  flatShading: false,
                  side: THREE.DoubleSide,
                });
              }

              if (this.model) {
                this.scene.remove(this.model);
              }

              this.model = new THREE.Mesh(geometry, material);

              geometry.computeBoundingBox();
              const center = new THREE.Vector3();
              geometry.boundingBox.getCenter(center);
              this.model.position.sub(center);

              this.model.castShadow = true;
              this.model.receiveShadow = true;
              this.scene.add(this.model);
            });
          } catch (error) {
            console.error("Color mode reload error:", error);
          }
        }

        toggleBoundingBox(active) {
          if (!active) {
            const bbox = this.scene.getObjectByName("boundingBox");
            if (bbox) {
              this.scene.remove(bbox);
            }
            return;
          }

          if (this.model) {
            const box = new THREE.Box3().setFromObject(this.model);
            const size = new THREE.Vector3();
            box.getSize(size);
            const center = new THREE.Vector3();
            box.getCenter(center);

            // Add padding
            const dims = [size.x, size.y, size.z];
            const minIndex = dims.indexOf(Math.min(...dims));

            if (minIndex === 0) size.x += 0.5;
            else size.x += 1.0;
            if (minIndex === 1) size.y += 0.5;
            else size.y += 1.0;
            if (minIndex === 2) size.z += 0.5;
            else size.z += 1.0;

            const boxGeom = new THREE.BoxGeometry(size.x, size.y, size.z);
            const boxMat = new THREE.MeshBasicMaterial({
              color: 0x999999,
              transparent: true,
              opacity: 0.8,
            });
            const bboxMesh = new THREE.Mesh(boxGeom, boxMat);
            bboxMesh.name = "boundingBox";
            bboxMesh.position.copy(center);
            this.scene.add(bboxMesh);
          }
        }

        setupToggle(id, callback, initialState = false) {
          const toggle = document.getElementById(id);
          let active = initialState;

          if (initialState) {
            toggle.classList.add("active");
          }

          toggle.addEventListener("click", () => {
            active = !active;
            toggle.classList.toggle("active", active);
            callback(active);
          });
        }

        checkForAnalysisId() {
          // URL'den analysis_id ve access_token al
          const path = window.location.pathname;

          // Format 1: /step-viewer/{analysis_id}/{access_token}
          const fullMatch = path.match(/\/step-viewer\/([^\/]+)\/([^\/]+)$/);

          // Format 2: /step-viewer/{analysis_id}
          const simpleMatch = path.match(/\/step-viewer\/([^\/]+)$/);

          if (fullMatch) {
            this.currentAnalysisId = fullMatch[1];
            this.accessToken = fullMatch[2];
            console.log(
              "[VIEWER] üîê Token ile eri≈üim:",
              this.currentAnalysisId
            );
            this.loadAnalysisModel(this.currentAnalysisId);
          } else if (simpleMatch) {
            this.currentAnalysisId = simpleMatch[1];
            this.accessToken = null;
            console.log("[VIEWER] üìã Basit eri≈üim:", this.currentAnalysisId);
            this.loadAnalysisModel(this.currentAnalysisId);
          } else {
            console.log("[VIEWER] üè† Ana sayfa");
            this.showMainPage();
          }
        }

        async loadAnalysisModel(analysisId) {
          try {
            this.showLoading("3D model y√ºkleniyor...");

            const headers = {
              "Content-Type": "application/json",
            };

            if (this.accessToken) {
              headers["Authorization"] = `Bearer ${this.accessToken}`;
            }

            // Try to load STL directly first
            const modelPath = `/static/stepviews/${analysisId}/model_${analysisId}.stl`;

            try {
              await this.loadSTLFromPath(modelPath);
              await this.loadAnalysisInfo(analysisId);
              this.showToast("3D model ba≈üarƒ±yla y√ºklendi!", "success");
              this.hideLoading();
              return;
            } catch (stlLoadError) {
              console.log("[VIEWER] Direct STL load failed, trying API...");
            }

            // If direct STL fails, try API approach
            const modelInfoResponse = await fetch(
              `/api/upload/model-3d/${analysisId}`,
              {
                method: "GET",
                headers: headers,
              }
            );

            if (!modelInfoResponse.ok) {
              throw new Error(
                `Model bilgileri alƒ±namadƒ± (${modelInfoResponse.status})`
              );
            }

            const modelInfo = await modelInfoResponse.json();
            console.log("[VIEWER] üìä Model bilgileri:", modelInfo);

            let stlPath = null;

            if (
              modelInfo.success &&
              modelInfo.model_info.models_available.stl?.ready
            ) {
              stlPath = modelInfo.model_info.models_available.stl.path;
              console.log("[VIEWER] ‚úÖ STL dosyasƒ± mevcut:", stlPath);

              try {
                await this.loadSTLFromPath(stlPath);
                await this.loadAnalysisInfo(analysisId);
                this.showToast("3D model ba≈üarƒ±yla y√ºklendi!", "success");
                this.hideLoading();
                return;
              } catch (stlLoadError) {
                console.error("[VIEWER] ‚ùå STL y√ºkleme hatasƒ±:", stlLoadError);
              }
            }

            // Generate STL if not available
            if (!stlPath || !modelInfo.model_info.models_available.stl?.ready) {
              console.log("[VIEWER] üîß STL olu≈üturuluyor...");
              this.showLoading("STL dosyasƒ± olu≈üturuluyor...");

              const analyzeResponse = await fetch(
                `/api/upload/analyze/${analysisId}`,
                {
                  method: "POST",
                  headers: headers,
                }
              );

              if (analyzeResponse.ok) {
                const analyzeResult = await analyzeResponse.json();
                console.log("[VIEWER] ‚úÖ Analiz tamamlandƒ±:", analyzeResult);
              }

              const generateResponse = await fetch(
                `/api/upload/generate-stl/${analysisId}`,
                {
                  method: "POST",
                  headers: headers,
                }
              );

              if (generateResponse.ok) {
                const generateResult = await generateResponse.json();
                console.log(
                  "[VIEWER] üì¶ STL olu≈üturma sonucu:",
                  generateResult
                );

                if (generateResult.success) {
                  const newStlPath =
                    generateResult.stl_url || generateResult.stl_path;
                  console.log("[VIEWER] üîÑ Yeni STL y√ºkleniyor:", newStlPath);

                  await this.loadSTLFromPath(newStlPath);
                  await this.loadAnalysisInfo(analysisId);

                  this.showToast(
                    "3D model olu≈üturuldu ve y√ºklendi!",
                    "success"
                  );
                  this.hideLoading();
                  return;
                } else {
                  throw new Error(
                    generateResult.message || "STL olu≈üturulamadƒ±"
                  );
                }
              } else {
                throw new Error(
                  `STL olu≈üturulamadƒ± (${generateResponse.status})`
                );
              }
            }
          } catch (error) {
            console.error("[VIEWER] ‚ùå Model y√ºkleme hatasƒ±:", error);
            this.showToast(`Model y√ºklenemedi: ${error.message}`, "error");
            this.showErrorState(error.message);
          } finally {
            this.hideLoading();
          }
        }

        async loadAnalysisInfo(analysisId) {
          try {
            const headers = {
              "Content-Type": "application/json",
            };

            if (this.accessToken) {
              headers["Authorization"] = `Bearer ${this.accessToken}`;
            }

            const configUrl = this.accessToken
              ? `/api/step-viewer/config/${analysisId}/${this.accessToken}`
              : `/api/step-viewer/config/${analysisId}`;

            const configResponse = await fetch(configUrl, {
              method: "GET",
              headers: headers,
            });

            if (configResponse.ok) {
              const configData = await configResponse.json();
              if (configData.success && configData.config) {
                const analysis = {
                  original_filename:
                    configData.config.file_info.original_filename,
                  file_type: configData.config.file_info.file_type,
                  step_analysis: configData.config.step_analysis,
                  enhanced_renders: configData.config.enhanced_renders,
                };

                this.displayAnalysisInfo(analysis);
              }
            }
          } catch (error) {
            console.warn("[VIEWER] Analiz bilgileri y√ºklenemedi:", error);
          }
        }

        async loadSTLFromPath(stlPath) {
          return new Promise((resolve, reject) => {
            console.log("[STL-LOADER] üìÅ STL y√ºkleme ba≈ülƒ±yor:", stlPath);

            if (!stlPath.startsWith("/")) {
              stlPath = "/" + stlPath;
            }

            console.log("[STL-LOADER] üìç Normalized path:", stlPath);

            const loader = new STLLoader();

            loader.load(
              stlPath,
              (geometry) => {
                try {
                  console.log("[STL-LOADER] ‚úÖ Geometry y√ºklendi:", {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index
                      ? geometry.index.count / 3
                      : "calculated",
                  });

                  this.processLoadedGeometry(geometry);
                  console.log("[STL-LOADER] ‚úÖ STL ba≈üarƒ±yla i≈ülendi");
                  resolve();
                } catch (error) {
                  console.error(
                    "[STL-LOADER] ‚ùå Geometry i≈üleme hatasƒ±:",
                    error
                  );
                  reject(error);
                }
              },
              (progress) => {
                if (progress.total > 0) {
                  const percent = Math.round(
                    (progress.loaded / progress.total) * 100
                  );
                  console.log(
                    `[STL-LOADER] üìä Y√ºkleme ilerlemesi: ${percent}% (${progress.loaded}/${progress.total})`
                  );
                  this.showLoading(`STL y√ºkleniyor... ${percent}%`);
                }
              },
              (error) => {
                console.error("[STL-LOADER] ‚ùå STL y√ºkleme hatasƒ±:", {
                  error: error,
                  path: stlPath,
                  errorType: error.type || "unknown",
                  message: error.message || error.toString(),
                });

                let errorMessage = "STL dosyasƒ± y√ºklenemedi";
                if (error.message) {
                  errorMessage += `: ${error.message}`;
                } else if (error.type === "load") {
                  errorMessage += " - Dosya bulunamadƒ± veya eri≈üilemiyor";
                }

                reject(new Error(errorMessage));
              }
            );
          });
        }

        processLoadedGeometry(geometry) {
          geometry.computeVertexNormals();
          geometry.computeBoundingBox();

          const center = new THREE.Vector3();
          geometry.boundingBox.getCenter(center);
          geometry.translate(-center.x, -center.y, -center.z);

          let material;
          if (this.currentColorMode === "vertex") {
            const colors = [];
            const position = geometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
              const y = position.getY(i);
              const color = new THREE.Color().setHSL((y + 50) / 100, 1.0, 0.5);
              colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute(
              "color",
              new THREE.Float32BufferAttribute(colors, 3)
            );
            material = new THREE.MeshPhongMaterial({
              vertexColors: true,
              side: THREE.DoubleSide,
              shininess: 100,
            });
          } else {
            material = new THREE.MeshPhongMaterial({
              color: 0xb0bec5,
              shininess: 25,
              specular: 0x222222,
              flatShading: false,
              side: THREE.DoubleSide,
            });
          }

          if (this.model) {
            this.scene.remove(this.model);
          }

          this.model = new THREE.Mesh(geometry, material);
          this.model.castShadow = true;
          this.model.receiveShadow = true;
          this.scene.add(this.model);

          this.fitToView();

          const container = document.getElementById("viewer-container");
          container.innerHTML = "";
          container.appendChild(this.renderer.domElement);

          // Setup measurement event listeners after renderer is added
          this.setupMeasurementEvents();
        }

        displayAnalysisInfo(analysis) {
          const analysisDetails = document.getElementById("model-info");
          const stepAnalysis = analysis.step_analysis || {};

          let detailsHTML = `
            <div class="info-row">
              <span class="info-label">Durum:</span>
              <span class="info-value" style="color: #27ae60;">Y√ºklendi</span>
            </div>
            <div class="info-row">
              <span class="info-label">Dosya:</span>
              <span class="info-value">${
                analysis.original_filename || "Bilinmeyen"
              }</span>
            </div>
            <div class="info-row">
              <span class="info-label">Tip:</span>
              <span class="info-value">${analysis.file_type || "STL"}</span>
            </div>
          `;

          if (stepAnalysis["X (mm)"]) {
            const volume = stepAnalysis["Prizma Hacmi (mm¬≥)"] || 0;
            const surfaceArea = stepAnalysis["Toplam Y√ºzey Alanƒ± (mm¬≤)"] || 0;

            detailsHTML += `
              <div class="info-row">
                <span class="info-label">Geni≈ülik:</span>
                <span class="info-value">${stepAnalysis["X (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Y√ºkseklik:</span>
                <span class="info-value">${stepAnalysis["Y (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Derinlik:</span>
                <span class="info-value">${stepAnalysis["Z (mm)"]} mm</span>
              </div>
              <div class="info-row">
                <span class="info-label">Hacim:</span>
                <span class="info-value">${volume.toLocaleString()} mm¬≥</span>
              </div>
              <div class="info-row">
                <span class="info-label">Y√ºzey:</span>
                <span class="info-value">${surfaceArea.toLocaleString()} mm¬≤</span>
              </div>
            `;
          }

          analysisDetails.innerHTML = detailsHTML;
        }

        showMainPage() {
          const container = document.getElementById("viewer-container");

          const mainPageContainer = document.createElement("div");
          mainPageContainer.className = "main-page";

          const welcomeIcon = document.createElement("div");
          welcomeIcon.className = "welcome-icon";
          welcomeIcon.textContent = "üéØ";

          const welcomeText = document.createElement("div");
          welcomeText.className = "welcome-text";
          welcomeText.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 15px; color: #3498db;">üîß EngTeklif 3D Viewer</div>
            <div style="font-size: 16px; margin-bottom: 20px;">3D STEP model g√∂r√ºnt√ºleyici</div>
            <div style="font-size: 14px; color: #7f8c8d; line-height: 1.6;">
                Model g√∂r√ºnt√ºlemek i√ßin doƒüru URL formatƒ±nƒ± kullanƒ±n:<br><br>
                üìã <strong>/step-viewer/{analysis_id}</strong><br>
                üîê <strong>/step-viewer/{analysis_id}/{access_token}</strong>
            </div>
          `;

          const uploadButton = document.createElement("button");
          uploadButton.className = "btn";
          uploadButton.innerHTML = "üìÅ Dosya Y√ºkle";
          uploadButton.onclick = () => {
            window.location.href = "/api/upload/supported-formats";
          };

          mainPageContainer.appendChild(welcomeIcon);
          mainPageContainer.appendChild(welcomeText);
          mainPageContainer.appendChild(uploadButton);
          container.innerHTML = "";
          container.appendChild(mainPageContainer);

          document.getElementById("status-value").textContent = "Hazƒ±r";
          document.getElementById("status-value").style.color = "#27ae60";
        }

        showErrorState(message) {
          const container = document.getElementById("viewer-container");

          const errorContainer = document.createElement("div");
          errorContainer.className = "error-state";

          const errorIcon = document.createElement("div");
          errorIcon.className = "error-icon";
          errorIcon.textContent = "‚ö†Ô∏è";

          const errorText = document.createElement("div");
          errorText.className = "error-text";
          errorText.innerHTML = `
            <div style="font-size: 18px; margin-bottom: 10px;">Model Y√ºklenemedi</div>
            <div style="font-size: 14px; color: #7f8c8d;">${message}</div>
          `;

          const backButton = document.createElement("button");
          backButton.className = "btn";
          backButton.textContent = "üè† Ana Sayfaya D√∂n";
          backButton.onclick = () => {
            window.location.href = "/step-viewer";
          };

          errorContainer.appendChild(errorIcon);
          errorContainer.appendChild(errorText);
          errorContainer.appendChild(backButton);
          container.innerHTML = "";
          container.appendChild(errorContainer);
        }

        resetView() {
          if (this.model) {
            this.camera.position.set(50, 50, 50);
            this.camera.lookAt(0, 0, 0);
            this.controls.target.set(0, 0, 0);
            this.controls.update();
          }
        }

        fitToView() {
          if (this.model) {
            const box = new THREE.Box3().setFromObject(this.model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = this.camera.fov * (Math.PI / 180);
            const cameraDistance =
              Math.abs(maxDim / (2 * Math.tan(fov / 2))) * 1.5;

            const direction = new THREE.Vector3(1, 1, 1).normalize();
            this.camera.position.copy(direction.multiplyScalar(cameraDistance));
            this.camera.lookAt(center);

            this.controls.target.copy(center);
            this.controls.update();
          }
        }

        setStandardView(viewType) {
          if (!this.model) return;

          const box = new THREE.Box3().setFromObject(this.model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const distance = maxDim * 2;

          const positions = {
            front: [center.x, center.y, center.z + distance],
            back: [center.x, center.y, center.z - distance],
            left: [center.x - distance, center.y, center.z],
            right: [center.x + distance, center.y, center.z],
            top: [center.x, center.y + distance, center.z],
            bottom: [center.x, center.y - distance, center.z],
            isometric: [
              center.x + distance * 0.7,
              center.y + distance * 0.7,
              center.z + distance * 0.7,
            ],
          };

          const position = positions[viewType];
          if (position) {
            this.camera.position.set(...position);
            this.camera.lookAt(center);
            this.controls.target.copy(center);
            this.controls.update();
          }
        }

        setMaterial(materialType) {
          if (!this.model) return;

          const materials = {
            aluminum: { color: 0xc0c0c0, shininess: 100 },
            steel: { color: 0x708090, shininess: 80 },
            plastic: { color: 0x4a90e2, shininess: 30 },
          };

          const materialConfig = materials[materialType];
          if (materialConfig) {
            this.model.material.color.setHex(materialConfig.color);
            this.model.material.shininess = materialConfig.shininess;
          }
        }

        showLoading(message = "Y√ºkleniyor...") {
          const loading = document.getElementById("loading");
          const loadingText = document.getElementById("loading-text");
          loadingText.textContent = message;
          loading.classList.add("show");
          this.isLoading = true;
        }

        hideLoading() {
          document.getElementById("loading").classList.remove("show");
          this.isLoading = false;
        }

        showToast(message, type = "success") {
          const toast = document.getElementById("toast");
          toast.textContent = message;
          toast.className = `toast ${type}`;

          // Add info class for measurement feedback
          if (type === "info") {
            toast.style.background =
              "linear-gradient(135deg, #3498db 0%, #2980b9 100%)";
            toast.style.boxShadow = "0 8px 25px rgba(52, 152, 219, 0.3)";
          }

          toast.classList.add("show");

          setTimeout(() => {
            toast.classList.remove("show");
            // Reset style for next use
            if (type === "info") {
              toast.style.background = "";
              toast.style.boxShadow = "";
            }
          }, 3000);
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          if (this.controls) {
            this.controls.update();
          }

          // Update preview line during measurement
          if (window._previewLine && this.selectedPoints.length === 1) {
            const positions =
              window._previewLine.geometry.attributes.position.array;
            positions[3] = this.mouse3D.x;
            positions[4] = this.mouse3D.y;
            positions[5] = this.mouse3D.z;
            window._previewLine.geometry.attributes.position.needsUpdate = true;
          }

          if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
          }
        }
      }

      // Initialize the viewer
      window.addEventListener("DOMContentLoaded", () => {
        new EngTeklifSTEPViewer();
      });
    </script>
  </body>
</html>
