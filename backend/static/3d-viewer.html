<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>STEP 3D Viewer - EngTeklif</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        background: #0a0a0a;
        color: #fff;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 100;
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 10px;
        display: flex;
        gap: 10px;
        z-index: 100;
      }

      button {
        background: #4a9eff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      }

      button:hover {
        background: #357abd;
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 200;
      }

      .spinner {
        border: 3px solid rgba(255, 255, 255, 0.1);
        border-top-color: #4a9eff;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #error {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        background: rgba(255, 0, 0, 0.1);
        border: 1px solid #ff0000;
        padding: 20px;
        border-radius: 10px;
        display: none;
      }

      #tokenInput {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }

      #tokenInput input {
        padding: 5px;
        margin-right: 5px;
        border: 1px solid #444;
        background: #222;
        color: white;
        border-radius: 3px;
      }

      #tokenInput button {
        padding: 5px 10px;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <div>3D Model Viewer</div>
      <div id="status">Yükleniyor...</div>
    </div>

    <div id="tokenInput">
      <input
        type="password"
        id="tokenField"
        placeholder="JWT Token (opsiyonel)"
        style="width: 200px"
      />
      <button onclick="setToken()">Token Ayarla</button>
    </div>

    <div id="loading">
      <div class="spinner"></div>
      <div>Model yükleniyor...</div>
    </div>

    <div id="error">
      <h3>Hata!</h3>
      <p id="errorMsg"></p>
      <button onclick="retryWithoutToken()">Token Olmadan Dene</button>
    </div>

    <div id="controls">
      <button onclick="toggleWireframe()">Wireframe</button>
      <button onclick="toggleRotation()">Otomatik Döndür</button>
      <button onclick="resetView()">Sıfırla</button>
    </div>

    <script>
      // Global değişkenler
      let scene, camera, renderer;
      let model;
      let autoRotate = true;
      let wireframeMode = false;

      // URL'den analysis ID'yi al
      const urlParams = new URLSearchParams(window.location.search);
      const analysisId = urlParams.get("analysis_id");

      console.log("Analysis ID:", analysisId);

      // Token kontrolü
      let token = localStorage.getItem("token") || urlParams.get("token");
      if (token) {
        document.getElementById("tokenField").value =
          token === "embedded" ? "" : token.substring(0, 20) + "...";
      }

      // Three.js sahnesini başlat
      function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);

        // Grid
        const gridHelper = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Axes
        const axesHelper = new THREE.AxesHelper(50);
        scene.add(axesHelper);

        // Mouse controls
        setupControls();

        // Window resize
        window.addEventListener("resize", onWindowResize);

        // Model yükle
        if (analysisId) {
          loadWireframeData(analysisId);
        } else {
          // Test modeli oluştur
          createTestModel();
        }

        // Animation loop
        animate();
      }

      function setupControls() {
        let mouseX = 0,
          mouseY = 0;
        let isDragging = false;

        renderer.domElement.addEventListener("mousedown", () => {
          isDragging = true;
        });

        renderer.domElement.addEventListener("mouseup", () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener("mousemove", (e) => {
          if (isDragging) {
            const deltaX = e.movementX * 0.5;
            const deltaY = e.movementY * 0.5;

            // Kamerayı döndür
            const spherical = new THREE.Spherical();
            spherical.setFromVector3(camera.position);
            spherical.theta -= deltaX * 0.01;
            spherical.phi += deltaY * 0.01;
            spherical.phi = Math.max(
              0.1,
              Math.min(Math.PI - 0.1, spherical.phi)
            );
            camera.position.setFromSpherical(spherical);
            camera.lookAt(0, 0, 0);
          }
        });

        // Zoom
        renderer.domElement.addEventListener("wheel", (e) => {
          e.preventDefault();
          const scale = e.deltaY > 0 ? 1.1 : 0.9;
          camera.position.multiplyScalar(scale);
        });
      }

      function createTestModel() {
        // Test için basit bir kutu
        const geometry = new THREE.BoxGeometry(50, 30, 20);
        const material = new THREE.MeshPhongMaterial({
          color: 0x4a9eff,
          wireframe: false,
        });

        model = new THREE.Mesh(geometry, material);
        scene.add(model);

        document.getElementById("loading").style.display = "none";
        document.getElementById("status").textContent = "Test modeli yüklendi";
      }

      async function loadWireframeData(analysisId, useToken = true) {
        try {
          console.log("Wireframe data yükleniyor...");

          const headers = {};
          if (useToken && token && token !== "embedded") {
            headers["Authorization"] = `Bearer ${token}`;
          }

          // API URL'i belirle
          const baseUrl = window.location.origin;
          const apiUrl = `${baseUrl}/api/upload/wireframe/${analysisId}`;

          console.log("API URL:", apiUrl);
          console.log("Token kullanılıyor:", useToken);

          const response = await fetch(apiUrl, { headers });

          if (!response.ok) {
            if (response.status === 401 && useToken) {
              console.log("401 hatası, token olmadan denenecek...");
              throw new Error("Yetkilendirme hatası. Token olmadan deneyin.");
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();
          console.log("Wireframe data:", data);

          if (data.success && data.wireframe_data) {
            createWireframeModel(data.wireframe_data);
            document.getElementById(
              "status"
            ).textContent = `Model yüklendi - ${data.wireframe_data.vertex_count} vertex`;
          } else {
            throw new Error(data.message || "Wireframe data alınamadı");
          }
        } catch (error) {
          console.error("Model yükleme hatası:", error);
          showError(error.message);
        }
      }

      function createWireframeModel(wireframeData) {
        // Eğer wireframe data yoksa test verisi kullan
        if (!wireframeData || !wireframeData.vertices) {
          console.log("Wireframe data eksik, test verisi kullanılıyor");
          wireframeData = {
            vertices: [
              [0, 0, 0],
              [50, 0, 0],
              [50, 30, 0],
              [0, 30, 0],
              [0, 0, 20],
              [50, 0, 20],
              [50, 30, 20],
              [0, 30, 20],
            ],
            edges: [
              [0, 1],
              [1, 2],
              [2, 3],
              [3, 0],
              [4, 5],
              [5, 6],
              [6, 7],
              [7, 4],
              [0, 4],
              [1, 5],
              [2, 6],
              [3, 7],
            ],
          };
        }

        const { vertices, edges } = wireframeData;

        // LineSegments için geometry oluştur
        const geometry = new THREE.BufferGeometry();
        const positions = [];

        // Her edge için vertex pozisyonlarını ekle
        edges.forEach((edge) => {
          const v1 = vertices[edge[0]];
          const v2 = vertices[edge[1]];
          positions.push(v1[0], v1[1], v1[2]);
          positions.push(v2[0], v2[1], v2[2]);
        });

        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );

        // Material
        const material = new THREE.LineBasicMaterial({
          color: 0x4a9eff,
          linewidth: 2,
        });

        // Model
        model = new THREE.LineSegments(geometry, material);
        scene.add(model);

        // Modeli ortala
        geometry.computeBoundingBox();
        const center = new THREE.Vector3();
        geometry.boundingBox.getCenter(center);
        model.position.sub(center);

        // Kamerayı ayarla
        const size = new THREE.Vector3();
        geometry.boundingBox.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z);
        camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
        camera.lookAt(0, 0, 0);

        document.getElementById("loading").style.display = "none";
        document.getElementById("error").style.display = "none";
      }

      function showError(message) {
        document.getElementById("loading").style.display = "none";
        document.getElementById("error").style.display = "block";
        document.getElementById("errorMsg").textContent = message;
        document.getElementById("status").textContent = "Hata!";
      }

      function animate() {
        requestAnimationFrame(animate);

        if (autoRotate && model) {
          model.rotation.y += 0.005;
        }

        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Kontrol fonksiyonları
      function toggleWireframe() {
        wireframeMode = !wireframeMode;
        if (model && model.material) {
          model.material.wireframe = wireframeMode;
        }
      }

      function toggleRotation() {
        autoRotate = !autoRotate;
      }

      function resetView() {
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);
        if (model) {
          model.rotation.set(0, 0, 0);
        }
      }

      function setToken() {
        const newToken = prompt("JWT Token girin:");
        if (newToken) {
          token = newToken;
          localStorage.setItem("token", token);
          location.reload();
        }
      }

      function retryWithoutToken() {
        document.getElementById("error").style.display = "none";
        document.getElementById("loading").style.display = "block";
        loadWireframeData(analysisId, false);
      }

      // Başlat
      init();
    </script>
  </body>
</html>
