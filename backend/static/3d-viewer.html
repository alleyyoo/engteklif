<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Model Viewer - EngTeklif</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        overflow: hidden;
        height: 100vh;
      }

      #container {
        position: relative;
        width: 100%;
        height: 100%;
      }

      #viewer {
        width: 100%;
        height: 100%;
        background: #1a1a1a;
      }

      #controls {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 10px;
        color: white;
        font-size: 14px;
        max-width: 300px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      #info {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 10px;
        color: white;
        font-size: 12px;
        max-width: 250px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 18px;
        text-align: center;
        z-index: 1000;
      }

      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #ffffff;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #error {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(220, 20, 60, 0.9);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        max-width: 400px;
        display: none;
        z-index: 1001;
      }

      .control-group {
        margin-bottom: 10px;
      }

      .control-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }

      button {
        background: linear-gradient(45deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin: 2px;
        transition: all 0.3s ease;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .info-row {
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
      }

      .info-label {
        font-weight: bold;
        color: #ccc;
      }

      .info-value {
        color: #fff;
      }

      #materialInfo {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
      }

      .material-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 8px;
        margin: 5px 0;
        border-radius: 5px;
        font-size: 11px;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  </head>
  <body>
    <div id="container">
      <div id="viewer"></div>

      <div id="loading">
        <div class="spinner"></div>
        <div>3D Model Y√ºkleniyor...</div>
      </div>

      <div id="error">
        <h3>‚ùå Hata</h3>
        <p id="errorMessage">3D model y√ºklenirken bir hata olu≈ütu.</p>
        <button onclick="location.reload()">Yeniden Dene</button>
      </div>

      <div id="controls" style="display: none">
        <h3>üéÆ Kontroller</h3>
        <div class="control-group">
          <button onclick="resetView()">üè† Ba≈ülangƒ±√ß G√∂r√ºn√ºm√º</button>
          <button onclick="toggleWireframe()">üìê Wireframe</button>
        </div>
        <div class="control-group">
          <button onclick="setView('front')">üìÑ √ñn</button>
          <button onclick="setView('top')">‚¨ÜÔ∏è √úst</button>
          <button onclick="setView('side')">‚û°Ô∏è Yan</button>
        </div>
        <div class="control-group">
          <label>D√∂nd√ºrme: Sol tƒ±k + s√ºr√ºkle</label>
          <label>Yakla≈ütƒ±rma: Tekerlek</label>
          <label>Kaydƒ±rma: Saƒü tƒ±k + s√ºr√ºkle</label>
        </div>
      </div>

      <div id="info" style="display: none">
        <h3>üìä Model Bilgileri</h3>
        <div class="info-row">
          <span class="info-label">Vertices:</span>
          <span class="info-value" id="vertexCount">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">Edges:</span>
          <span class="info-value" id="edgeCount">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">Boyutlar:</span>
          <span class="info-value" id="dimensions">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">Hacim:</span>
          <span class="info-value" id="volume">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">Geometri:</span>
          <span class="info-value" id="geometryType">-</span>
        </div>

        <div id="materialInfo">
          <h4>üîß Malzeme Bilgileri</h4>
          <div id="materialList"></div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let scene, camera, renderer, controls;
      let wireframeGroup, solidGroup;
      let isWireframeMode = false;
      let analysisId = null;
      let authToken = null;

      // Get URL parameters
      function getUrlParams() {
        const params = new URLSearchParams(window.location.search);
        analysisId = params.get("analysis_id");
        authToken = params.get("token");

        if (!analysisId) {
          showError("Analiz ID bulunamadƒ±");
          return false;
        }
        return true;
      }

      // Initialize Three.js scene
      function initScene() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        camera.position.set(100, 100, 100);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById("viewer").appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Controls (basic mouse controls)
        setupControls();

        // Groups for different render modes
        wireframeGroup = new THREE.Group();
        solidGroup = new THREE.Group();
        scene.add(wireframeGroup);
        scene.add(solidGroup);

        // Window resize handler
        window.addEventListener("resize", onWindowResize, false);
      }

      // Setup manual controls (since OrbitControls might not be available)
      function setupControls() {
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let targetRotationOnMouseDownX = 0;
        let targetRotationOnMouseDownY = 0;

        renderer.domElement.addEventListener("mousedown", onMouseDown, false);
        renderer.domElement.addEventListener("mouseup", onMouseUp, false);
        renderer.domElement.addEventListener("mousemove", onMouseMove, false);
        renderer.domElement.addEventListener("wheel", onMouseWheel, false);

        function onMouseDown(event) {
          event.preventDefault();
          isMouseDown = true;
          mouseX = event.clientX;
          mouseY = event.clientY;
          targetRotationOnMouseDownX = targetRotationX;
          targetRotationOnMouseDownY = targetRotationY;
        }

        function onMouseUp(event) {
          event.preventDefault();
          isMouseDown = false;
        }

        function onMouseMove(event) {
          event.preventDefault();
          if (isMouseDown) {
            mouseX = event.clientX;
            mouseY = event.clientY;
            targetRotationX =
              targetRotationOnMouseDownX + (mouseX - event.clientX) * 0.02;
            targetRotationY =
              targetRotationOnMouseDownY + (mouseY - event.clientY) * 0.02;
          }
        }

        function onMouseWheel(event) {
          event.preventDefault();
          const scale = event.deltaY > 0 ? 1.1 : 0.9;
          camera.position.multiplyScalar(scale);
        }

        // Animation loop for smooth rotation
        function animate() {
          requestAnimationFrame(animate);

          if (
            wireframeGroup.children.length > 0 ||
            solidGroup.children.length > 0
          ) {
            const group = isWireframeMode ? wireframeGroup : solidGroup;
            if (group.children.length > 0) {
              group.rotation.y += (targetRotationX - group.rotation.y) * 0.05;
              group.rotation.x += (targetRotationY - group.rotation.x) * 0.05;
            }
          }

          renderer.render(scene, camera);
        }
        animate();
      }

      // Load wireframe data from API
      async function loadWireframeData() {
        try {
          const response = await fetch(`/api/upload/wireframe/${analysisId}`, {
            method: "GET",
            headers: {
              Authorization: `Bearer ${authToken}`,
              "Content-Type": "application/json",
            },
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();

          if (data.success) {
            renderWireframe(data.wireframe_data);
            updateInfo(
              data.wireframe_data,
              data.step_analysis,
              data.material_info
            );
            hideLoading();
            showControls();
          } else {
            throw new Error(data.message || "Wireframe data alƒ±namadƒ±");
          }
        } catch (error) {
          console.error("Wireframe y√ºkleme hatasƒ±:", error);
          showError(`3D model y√ºklenemedi: ${error.message}`);
        }
      }

      // Render wireframe from data
      function renderWireframe(wireframeData) {
        if (!wireframeData || !wireframeData.vertices || !wireframeData.edges) {
          throw new Error("Ge√ßersiz wireframe data");
        }

        console.log("Wireframe data:", wireframeData);

        // Clear existing geometry
        clearScene();

        const vertices = wireframeData.vertices;
        const edges = wireframeData.edges;

        // Create wireframe
        const wireframeMaterial = new THREE.LineBasicMaterial({
          color: 0x00ff88,
          linewidth: 2,
        });

        edges.forEach((edge) => {
          if (edge.length >= 2 && vertices[edge[0]] && vertices[edge[1]]) {
            const geometry = new THREE.BufferGeometry();
            const points = [
              new THREE.Vector3(...vertices[edge[0]]),
              new THREE.Vector3(...vertices[edge[1]]),
            ];
            geometry.setFromPoints(points);

            const line = new THREE.Line(geometry, wireframeMaterial);
            wireframeGroup.add(line);
          }
        });

        // Create solid version (for wireframe toggle)
        if (wireframeData.geometry_type === "box") {
          createSolidBox(wireframeData.bounding_box.dimensions);
        } else if (wireframeData.geometry_type === "cylinder") {
          const dims = wireframeData.bounding_box.dimensions;
          createSolidCylinder(dims[0] / 2, dims[2]); // radius, height
        }

        // Center and scale the model
        centerAndScaleModel();
      }

      // Create solid box
      function createSolidBox(dimensions) {
        const [width, height, depth] = dimensions;
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshLambertMaterial({
          color: 0x4488ff,
          transparent: true,
          opacity: 0.7,
        });
        const mesh = new THREE.Mesh(geometry, material);
        solidGroup.add(mesh);
      }

      // Create solid cylinder
      function createSolidCylinder(radius, height) {
        const geometry = new THREE.CylinderGeometry(radius, radius, height, 16);
        const material = new THREE.MeshLambertMaterial({
          color: 0x4488ff,
          transparent: true,
          opacity: 0.7,
        });
        const mesh = new THREE.Mesh(geometry, material);
        solidGroup.add(mesh);
      }

      // Center and scale model
      function centerAndScaleModel() {
        const group = isWireframeMode ? wireframeGroup : solidGroup;

        if (group.children.length === 0) return;

        // Calculate bounding box
        const box = new THREE.Box3().setFromObject(group);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        // Center the model
        group.position.sub(center);

        // Scale to fit in view
        const maxDim = Math.max(size.x, size.y, size.z);
        if (maxDim > 0) {
          const scale = 200 / maxDim; // Adjust scale factor as needed
          group.scale.setScalar(scale);
        }

        // Position camera appropriately
        const distance = maxDim * 2;
        camera.position.set(distance, distance, distance);
        camera.lookAt(0, 0, 0);
      }

      // Clear scene
      function clearScene() {
        wireframeGroup.clear();
        solidGroup.clear();
      }

      // Update info panel
      function updateInfo(wireframeData, stepAnalysis, materialInfo) {
        document.getElementById("vertexCount").textContent =
          wireframeData.vertex_count || "-";
        document.getElementById("edgeCount").textContent =
          wireframeData.edge_count || "-";
        document.getElementById("geometryType").textContent =
          wireframeData.geometry_type || "-";

        if (
          wireframeData.bounding_box &&
          wireframeData.bounding_box.dimensions
        ) {
          const dims = wireframeData.bounding_box.dimensions;
          document.getElementById(
            "dimensions"
          ).textContent = `${dims[0]?.toFixed(1)} x ${dims[1]?.toFixed(
            1
          )} x ${dims[2]?.toFixed(1)} mm`;
        }

        if (stepAnalysis && stepAnalysis["√úr√ºn Hacmi (mm¬≥)"]) {
          const volume = stepAnalysis["√úr√ºn Hacmi (mm¬≥)"];
          document.getElementById(
            "volume"
          ).textContent = `${volume.toLocaleString()} mm¬≥`;
        }

        // Material info
        if (materialInfo && materialInfo.matches) {
          const materialList = document.getElementById("materialList");
          materialList.innerHTML = "";

          materialInfo.matches.forEach((match) => {
            const div = document.createElement("div");
            div.className = "material-item";
            div.textContent = match;
            materialList.appendChild(div);
          });
        }
      }

      // Control functions
      function resetView() {
        centerAndScaleModel();
      }

      function toggleWireframe() {
        isWireframeMode = !isWireframeMode;
        wireframeGroup.visible = isWireframeMode;
        solidGroup.visible = !isWireframeMode;
      }

      function setView(viewType) {
        const distance = 300;
        switch (viewType) {
          case "front":
            camera.position.set(0, 0, distance);
            break;
          case "top":
            camera.position.set(0, distance, 0);
            break;
          case "side":
            camera.position.set(distance, 0, 0);
            break;
        }
        camera.lookAt(0, 0, 0);
      }

      // Window resize handler
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // UI functions
      function hideLoading() {
        document.getElementById("loading").style.display = "none";
      }

      function showControls() {
        document.getElementById("controls").style.display = "block";
        document.getElementById("info").style.display = "block";
      }

      function showError(message) {
        hideLoading();
        document.getElementById("errorMessage").textContent = message;
        document.getElementById("error").style.display = "block";
      }

      // Initialize everything
      async function init() {
        try {
          // Get URL parameters
          if (!getUrlParams()) {
            return;
          }

          // Initialize Three.js scene
          initScene();

          // Load wireframe data
          await loadWireframeData();
        } catch (error) {
          console.error("Initialization error:", error);
          showError(`Ba≈ülatma hatasƒ±: ${error.message}`);
        }
      }

      // Start when page loads
      window.addEventListener("load", init);

      // Handle page visibility changes
      document.addEventListener("visibilitychange", function () {
        if (document.hidden) {
          // Pause rendering when tab is not visible
          return;
        } else {
          // Resume rendering when tab becomes visible
          return;
        }
      });

      // Keyboard shortcuts
      document.addEventListener("keydown", function (event) {
        switch (event.key) {
          case "r":
          case "R":
            resetView();
            event.preventDefault();
            break;
          case "w":
          case "W":
            toggleWireframe();
            event.preventDefault();
            break;
          case "1":
            setView("front");
            event.preventDefault();
            break;
          case "2":
            setView("top");
            event.preventDefault();
            break;
          case "3":
            setView("side");
            event.preventDefault();
            break;
          case "Escape":
            resetView();
            event.preventDefault();
            break;
        }
      });

      // Performance monitoring
      let lastTime = performance.now();
      let frameCount = 0;

      function updatePerformance() {
        frameCount++;
        const currentTime = performance.now();

        if (currentTime - lastTime >= 1000) {
          const fps = Math.round(
            (frameCount * 1000) / (currentTime - lastTime)
          );
          console.log(`FPS: ${fps}`);
          frameCount = 0;
          lastTime = currentTime;
        }

        requestAnimationFrame(updatePerformance);
      }

      // Start performance monitoring
      updatePerformance();

      // Debug info
      console.log("3D Model Viewer initialized");
      console.log("THREE.js version:", THREE.REVISION);
      console.log("WebGL support:", !!window.WebGLRenderingContext);
    </script>

    <!-- Keyboard shortcuts help -->
    <div
      style="
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 11px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      "
    >
      <strong>‚å®Ô∏è Kƒ±sayollar:</strong><br />
      R - G√∂r√ºn√ºm√º Sƒ±fƒ±rla | W - Wireframe | 1-3 - G√∂r√ºn√ºmler | ESC - Sƒ±fƒ±rla
    </div>

    <!-- WebGL compatibility check -->
    <script>
      // WebGL support check
      function checkWebGLSupport() {
        try {
          const canvas = document.createElement("canvas");
          const gl =
            canvas.getContext("webgl") ||
            canvas.getContext("experimental-webgl");
          return !!gl;
        } catch (e) {
          return false;
        }
      }

      if (!checkWebGLSupport()) {
        showError("WebGL desteklenmiyor. Modern bir tarayƒ±cƒ± kullanƒ±n.");
      }

      // Mobile device detection and warnings
      function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        );
      }

      if (isMobileDevice()) {
        console.log("Mobile device detected - adjusting controls");
        // Could add touch controls here
      }

      // Browser compatibility warnings
      if (!window.requestAnimationFrame) {
        console.warn("requestAnimationFrame not supported");
      }

      if (!window.WebGLRenderingContext) {
        showError("WebGL desteklenmiyor");
      }
    </script>
  </body>
</html>
